{
    "path": "jsonpath/jsonpath.go",
    "model_usage_metrics": {
        "Duration": 18347628047,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "jsonpath_test.go",
    "existing_test_code": "",
    "original_code": "package jsonpath\n\n// copied from https://raw.githubusercontent.com/mdaverde/jsonpath/jsonpath.go\n// TODO: don't copy it\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype DoesNotExist struct{}\n\nfunc (d DoesNotExist) Error() string {\n\treturn \"path not found\"\n}\n\nvar invalidObjError = errors.New(\"invalid object\")\nvar pathDelimiter = \".\"\n\nfunc tokenizePath(path string) ([]string, error) {\n\tvar tokens []string\n\tfor _, stem := range strings.Split(path, pathDelimiter) {\n\t\tif !strings.Contains(stem, \"[\") {\n\t\t\ttokens = append(tokens, stem)\n\t\t\tcontinue\n\t\t}\n\t\tfirstBracketIndex := strings.Index(stem, \"[\")\n\t\tlastBracketIndex := strings.LastIndex(stem, \"]\")\n\t\tif lastBracketIndex \u003c 0 {\n\t\t\treturn nil, fmt.Errorf(\"invalid path: %v\", path)\n\t\t}\n\t\ttokens = append(tokens, stem[0:firstBracketIndex])\n\t\tinnerText := stem[firstBracketIndex+1 : lastBracketIndex]\n\t\ttokens = append(tokens, innerText)\n\t}\n\treturn tokens, nil\n}\n\nfunc getToken(obj interface{}, token string) (interface{}, error) {\n\tif reflect.TypeOf(obj) == nil {\n\t\treturn nil, invalidObjError\n\t}\n\n\tswitch reflect.ValueOf(obj).Kind() {\n\tcase reflect.Map:\n\t\tfor _, kv := range reflect.ValueOf(obj).MapKeys() {\n\t\t\tif kv.String() == token {\n\t\t\t\treturn reflect.ValueOf(obj).MapIndex(kv).Interface(), nil\n\t\t\t}\n\t\t}\n\t\treturn nil, DoesNotExist{}\n\tcase reflect.Slice:\n\t\tidx, err := strconv.Atoi(token)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlength := reflect.ValueOf(obj).Len()\n\t\tif idx \u003e -1 {\n\t\t\tif idx \u003e= length {\n\t\t\t\treturn nil, DoesNotExist{}\n\t\t\t}\n\t\t\treturn reflect.ValueOf(obj).Index(idx).Interface(), nil\n\t\t}\n\t\treturn nil, DoesNotExist{}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"object is not a map or a slice: %v\", reflect.ValueOf(obj).Kind())\n\t}\n}\n\nfunc getByTokens(data interface{}, tokens []string) (interface{}, error) {\n\tvar err error\n\n\tchild := data\n\tfor _, token := range tokens {\n\t\tchild, err = getToken(child, token)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif child != nil {\n\t\treturn child, nil\n\t}\n\n\treturn nil, errors.New(\"could not get value at path\")\n}\n\nfunc followPtr(data interface{}) interface{} {\n\trv := reflect.ValueOf(data)\n\tfor rv.Kind() == reflect.Ptr {\n\t\trv = rv.Elem()\n\t}\n\treturn rv.Interface()\n}\n\nfunc Get(data interface{}, path string) (interface{}, error) {\n\tvar err error\n\ttokens, err := tokenizePath(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata = followPtr(data)\n\n\treturn getByTokens(data, tokens)\n}\n\nfunc Set(data interface{}, path string, value interface{}) error {\n\ttokens, err := tokenizePath(path)\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\thead := tokens[:len(tokens)-1]\n\tlast := tokens[len(tokens)-1]\n\n\tdata = followPtr(data)\n\tvalue = followPtr(value)\n\n\tchild := data\n\tparent := data\n\n\tfor tokenIdx, token := range head {\n\t\tchild, err = getToken(parent, token)\n\t\tif err != nil {\n\t\t\tif _, ok := err.(DoesNotExist); !ok \u0026\u0026 err != invalidObjError {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tchild = map[string]interface{}{}\n\n\t\t\tif tokenIdx+1 \u003c len(tokens) {\n\t\t\t\tnextToken := tokens[tokenIdx+1]\n\t\t\t\tif idx, err := strconv.Atoi(nextToken); err == nil {\n\t\t\t\t\tvar childSlice []interface{}\n\t\t\t\t\tfor i := 0; i \u003c idx; i++ {\n\t\t\t\t\t\tchildSlice = append(childSlice, nil)\n\t\t\t\t\t}\n\t\t\t\t\tchild = append(childSlice, map[string]interface{}{})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch reflect.ValueOf(parent).Kind() {\n\t\t\tcase reflect.Map:\n\t\t\t\treflect.ValueOf(parent).SetMapIndex(reflect.ValueOf(token), reflect.ValueOf(child))\n\t\t\tcase reflect.Slice:\n\t\t\t\tsliceValue := reflect.ValueOf(parent)\n\t\t\t\tidx, err := strconv.Atoi(token)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tsliceValue.Index(idx).Set(reflect.ValueOf(child))\n\t\t\tdefault:\n\t\t\t\treturn errors.New(\"path contains items that are not maps nor structs\")\n\t\t\t}\n\t\t}\n\n\t\tparent = child\n\t}\n\n\tswitch reflect.ValueOf(child).Kind() {\n\tcase reflect.Map:\n\t\treflect.ValueOf(child).SetMapIndex(reflect.ValueOf(last), reflect.ValueOf(value))\n\t\treturn nil\n\tcase reflect.Slice:\n\t\tsliceValue := reflect.ValueOf(child)\n\t\tidx, err := strconv.Atoi(last)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tsliceValue.Index(idx).Set(reflect.ValueOf(value))\n\t\treturn nil\n\t}\n\n\treturn errors.New(\"could not set value at path\")\n}\n",
    "test_code": "package jsonpath\n\nimport (\n\t\"testing\"\n)\n\nfunc TestGet_HappyPath(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"name\": \"John\",\n\t\t\"age\":  30,\n\t}\n\n\tresult, err := Get(data, \"name\")\n\tif err != nil {\n\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t}\n\tif result.(string) != \"John\" {\n\t\tt.Errorf(\"Expected 'John', got %v\", result)\n\t}\n}\n\nfunc TestGet_NegativePath(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"name\": \"John\",\n\t\t\"age\":  30,\n\t}\n\n\tresult, err := Get(data, \"address\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %v\", result)\n\t}\n}\n\nfunc TestGet_InvalidObject(t *testing.T) {\n\tdata := 123\n\n\tresult, err := Get(data, \"name\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %v\", result)\n\t}\n}\n\nfunc TestGet_EmptyPath(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"name\": \"John\",\n\t\t\"age\":  30,\n\t}\n\n\tresult, err := Get(data, \"\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, got %v\", result)\n\t}\n}\n\nfunc TestSet_HappyPath(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"name\": \"John\",\n\t\t\"age\":  30,\n\t}\n\n\terr := Set(data, \"name\", \"Jane\")\n\tif err != nil {\n\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t}\n\tif data[\"name\"].(string) != \"Jane\" {\n\t\tt.Errorf(\"Expected 'Jane', got %v\", data[\"name\"])\n\t}\n}\n\nfunc TestSet_NegativePath(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"name\": \"John\",\n\t\t\"age\":  30,\n\t}\n\n\terr := Set(data, \"address\", \"123 Main St\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n\tif data[\"address\"] != nil {\n\t\tt.Errorf(\"Expected nil, got %v\", data[\"address\"])\n\t}\n}\n\nfunc TestSet_InvalidObject(t *testing.T) {\n\tdata := 123\n\n\terr := Set(data, \"name\", \"Jane\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n\tif data != 123 {\n\t\tt.Errorf(\"Expected 123, got %v\", data)\n\t}\n}\n\nfunc TestSet_EmptyPath(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"name\": \"John\",\n\t\t\"age\":  30,\n\t}\n\n\terr := Set(data, \"\", \"Jane\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n\tif data != map[string]interface{}{\"name\": \"John\", \"age\": 30} {\n\t\tt.Errorf(\"Expected {\\\"name\\\": \\\"John\\\", \\\"age\\\": 30}, got %v\", data)\n\t}\n}\n\nfunc TestSet_NestedPath(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"user\": map[string]interface{}{\n\t\t\t\"name\": \"John\",\n\t\t\t\"age\":  30,\n\t\t},\n\t}\n\n\terr := Set(data, \"user.name\", \"Jane\")\n\tif err != nil {\n\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t}\n\tif data[\"user\"].(map[string]interface{})[\"name\"].(string) != \"Jane\" {\n\t\tt.Errorf(\"Expected 'Jane', got %v\", data[\"user\"].(map[string]interface{})[\"name\"])\n\t}\n}\n\nfunc TestSet_NestedPath_NotMap(t *testing.T) {\n\tdata := map[string]interface{}{\n\t\t\"user\": 123,\n\t}\n\n\terr := Set(data, \"user.name\", \"Jane\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n\tif data[\"user\"] != 123 {\n\t\tt.Errorf(\"Expected 123, got %v\", data[\"user\"])\n\t}\n}\n",
    "amount_of_generated_test_cases": 10,
    "single_test_run_command": "go test -v jsonpath_test.go"
}