{
    "path": "config/field_map.go",
    "model_usage_metrics": {
        "Duration": 34573953719,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "config/field_map_test.go",
    "existing_test_code": "",
    "original_code": "package config\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/qiangyt/jog/util\"\n)\n\n// FieldMapT ...\ntype FieldMapT struct {\n\tOthers                  OtherFields\n\tStandardsWithAllAliases map[string]Field\n\tStandards               map[string]Field\n}\n\n// FieldMap ...\ntype FieldMap = *FieldMapT\n\n// Reset ...\nfunc (i FieldMap) Reset() {\n\ti.Others = \u0026OtherFieldsT{}\n\ti.Others.Reset()\n\n\ti.Standards = make(map[string]Field)\n\ti.StandardsWithAllAliases = make(map[string]Field)\n}\n\n// UnmarshalYAML ...\nfunc (i FieldMap) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\treturn UnmarshalYAML(i, unmarshal)\n}\n\n// MarshalYAML ...\nfunc (i FieldMap) MarshalYAML() (interface{}, error) {\n\treturn MarshalYAML(i)\n}\n\n// Init ...\nfunc (i FieldMap) Init(cfg Configuration) {\n\n}\n\n// FromMap ...\nfunc (i FieldMap) FromMap(m map[string]interface{}) error {\n\tothersV := util.ExtractFromMap(m, \"others\")\n\tif othersV != nil {\n\t\tif err := util.UnmashalYAMLAgain(othersV, \u0026i.Others); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tfor k, v := range m {\n\t\t//if i.config.HasFieldInPattern(k) == false {\n\n\t\t//}\n\n\t\tvar f Field\n\t\tif err := util.UnmashalYAMLAgain(v, \u0026f); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif k == \"logger\" {\n\t\t\tk = \"logger\"\n\t\t}\n\t\tf.Name = k\n\t\ti.StandardsWithAllAliases[k] = f\n\t\ti.Standards[k] = f\n\n\t\tif !f.CaseSensitive {\n\t\t\tlk := strings.ToLower(k)\n\t\t\tif lk != k {\n\t\t\t\tif old, alreadyHas := i.StandardsWithAllAliases[lk]; old != f \u0026\u0026 alreadyHas {\n\t\t\t\t\treturn fmt.Errorf(\"duplicated field name: %s\", lk)\n\t\t\t\t}\n\t\t\t\ti.StandardsWithAllAliases[lk] = f\n\t\t\t}\n\t\t}\n\n\t\tvar aliases map[string]bool\n\t\tif !f.CaseSensitive {\n\t\t\taliases = f.Alias.Values\n\t\t} else {\n\t\t\taliases = f.Alias.LowercasedValues\n\t\t}\n\t\tfor aliasName := range aliases {\n\t\t\tif old, alreadyHas := i.StandardsWithAllAliases[aliasName]; old != f \u0026\u0026 alreadyHas {\n\t\t\t\treturn fmt.Errorf(\"duplicated field alias name: %s\", aliasName)\n\t\t\t}\n\t\t\ti.StandardsWithAllAliases[aliasName] = f\n\t\t}\n\n\t\tdelete(m, k)\n\t}\n\n\treturn nil\n}\n\n// ToMap ...\nfunc (i FieldMap) ToMap() map[string]interface{} {\n\tr := make(map[string]interface{})\n\tr[\"others\"] = i.Others.ToMap()\n\n\tfor k, v := range i.Standards {\n\t\tr[k] = v.ToMap()\n\t}\n\treturn r\n}\n",
    "test_code": "package config\n\nimport (\n\t\"testing\"\n)\n\nfunc TestFieldMap_Reset(t *testing.T) {\n\ti := \u0026FieldMapT{}\n\ti.Reset()\n\n\tif i.Others == nil || !i.Others.IsEmpty() {\n\t\tt.Errorf(\"Expected Others to be reset\")\n\t}\n\n\tif len(i.Standards) != 0 {\n\t\tt.Errorf(\"Expected Standards to be reset\")\n\t}\n\n\tif len(i.StandardsWithAllAliases) != 0 {\n\t\tt.Errorf(\"Expected StandardsWithAllAliases to be reset\")\n\t}\n}\n\nfunc TestFieldMap_UnmarshalYAML(t *testing.T) {\n\ti := \u0026FieldMapT{}\n\tdata := []byte(`others: {}\nstandards:\n  field1:\n    name: field1\n    case_sensitive: true\n    alias:\n      values: []\n      lowercased_values: []\n  field2:\n    name: field2\n    case_sensitive: false\n    alias:\n      values: [alias2]\n      lowercased_values: []`)\n\n\tif err := i.UnmarshalYAML(func(interface{}) error { return nil }); err != nil {\n\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t}\n\n\tif len(i.Standards) != 2 {\n\t\tt.Errorf(\"Expected 2 standards fields, got %d\", len(i.Standards))\n\t}\n\n\tif len(i.StandardsWithAllAliases) != 3 {\n\t\tt.Errorf(\"Expected 3 standards with all aliases fields, got %d\", len(i.StandardsWithAllAliases))\n\t}\n}\n\nfunc TestFieldMap_MarshalYAML(t *testing.T) {\n\ti := \u0026FieldMapT{}\n\tdata := []byte(`others: {}\nstandards:\n  field1:\n    name: field1\n    case_sensitive: true\n    alias:\n      values: []\n      lowercased_values: []\n  field2:\n    name: field2\n    case_sensitive: false\n    alias:\n      values: [alias2]\n      lowercased_values: []`)\n\n\tif err := i.UnmarshalYAML(func(interface{}) error { return nil }); err != nil {\n\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t}\n\n\tm, err := i.MarshalYAML()\n\tif err != nil {\n\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t}\n\n\texpected := `{\"others\":{},\"standards\":{\"field1\":{\"name\":\"field1\",\"case_sensitive\":true,\"alias\":{\"values\":[],\"lowercased_values\":[]}},\"field2\":{\"name\":\"field2\",\"case_sensitive\":false,\"alias\":{\"values\":[\"alias2\"],\"lowercased_values\":[]}}}}`\n\tif !strings.EqualFold(fmt.Sprintf(\"%v\", m), expected) {\n\t\tt.Errorf(\"Expected %s, got %s\", expected, fmt.Sprintf(\"%v\", m))\n\t}\n}\n\nfunc TestFieldMap_Init(t *testing.T) {\n\ti := \u0026FieldMapT{}\n\tcfg := Configuration{}\n\n\ti.Init(cfg)\n\n\tif i.Others == nil || !i.Others.IsEmpty() {\n\t\tt.Errorf(\"Expected Others to be initialized\")\n\t}\n\n\tif len(i.Standards) != 0 {\n\t\tt.Errorf(\"Expected Standards to be initialized\")\n\t}\n\n\tif len(i.StandardsWithAllAliases) != 0 {\n\t\tt.Errorf(\"Expected StandardsWithAllAliases to be initialized\")\n\t}\n}\n\nfunc TestFieldMap_FromMap(t *testing.T) {\n\ti := \u0026FieldMapT{}\n\tm := map[string]interface{}{\n\t\t\"others\": map[string]interface{}{},\n\t\t\"standards\": map[string]interface{}{\n\t\t\t\"field1\": map[string]interface{}{\n\t\t\t\t\"name\":        \"field1\",\n\t\t\t\t\"case_sensitive\": true,\n\t\t\t\t\"alias\": map[string]interface{}{\n\t\t\t\t\t\"values\": []interface{}{},\n\t\t\t\t\t\"lowercased_values\": []interface{}{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"field2\": map[string]interface{}{\n\t\t\t\t\"name\":        \"field2\",\n\t\t\t\t\"case_sensitive\": false,\n\t\t\t\t\"alias\": map[string]interface{}{\n\t\t\t\t\t\"values\": []interface{}{\"alias2\"},\n\t\t\t\t\t\"lowercased_values\": []interface{}{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := i.FromMap(m); err != nil {\n\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t}\n\n\tif len(i.Standards) != 2 {\n\t\tt.Errorf(\"Expected 2 standards fields, got %d\", len(i.Standards))\n\t}\n\n\tif len(i.StandardsWithAllAliases) != 3 {\n\t\tt.Errorf(\"Expected 3 standards with all aliases fields, got %d\", len(i.StandardsWithAllAliases))\n\t}\n}\n\nfunc TestFieldMap_ToMap(t *testing.T) {\n\ti := \u0026FieldMapT{}\n\tdata := []byte(`others: {}\nstandards:\n  field1:\n    name: field1\n    case_sensitive: true\n    alias:\n      values: []\n      lowercased_values: []\n  field2:\n    name: field2\n    case_sensitive: false\n    alias:\n      values: [alias2]\n      lowercased_values: []`)\n\n\tif err := i.UnmarshalYAML(func(interface{}) error { return nil }); err != nil {\n\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t}\n\n\tm := i.ToMap()\n\n\texpected := map[string]interface{}{\n\t\t\"others\": map[string]interface{}{},\n\t\t\"standards\": map[string]interface{}{\n\t\t\t\"field1\": map[string]interface{}{\n\t\t\t\t\"name\":        \"field1\",\n\t\t\t\t\"case_sensitive\": true,\n\t\t\t\t\"alias\": map[string]interface{}{\n\t\t\t\t\t\"values\": []interface{}{},\n\t\t\t\t\t\"lowercased_values\": []interface{}{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"field2\": map[string]interface{}{\n\t\t\t\t\"name\":        \"field2\",\n\t\t\t\t\"case_sensitive\": false,\n\t\t\t\t\"alias\": map[string]interface{}{\n\t\t\t\t\t\"values\": []interface{}{\"alias2\"},\n\t\t\t\t\t\"lowercased_values\": []interface{}{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(m, expected) {\n\t\tt.Errorf(\"Expected %v, got %v\", expected, m)\n\t}\n}\n\nfunc TestFieldMap_FromMap_DuplicateAlias(t *testing.T) {\n\ti := \u0026FieldMapT{}\n\tm := map[string]interface{}{\n\t\t\"others\": map[string]interface{}{},\n\t\t\"standards\": map[string]interface{}{\n\t\t\t\"field1\": map[string]interface{}{\n\t\t\t\t\"name\":        \"field1\",\n\t\t\t\t\"case_sensitive\": true,\n\t\t\t\t\"alias\": map[string]interface{}{\n\t\t\t\t\t\"values\": []interface{}{\"alias1\"},\n\t\t\t\t\t\"lowercased_values\": []interface{}{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"field2\": map[string]interface{}{\n\t\t\t\t\"name\":        \"field2\",\n\t\t\t\t\"case_sensitive\": false,\n\t\t\t\t\"alias\": map[string]interface{}{\n\t\t\t\t\t\"values\": []interface{}{\"alias1\"},\n\t\t\t\t\t\"lowercased_values\": []interface{}{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := i.FromMap(m); err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n}\n\nfunc TestFieldMap_FromMap_InvalidAlias(t *testing.T) {\n\ti := \u0026FieldMapT{}\n\tm := map[string]interface{}{\n\t\t\"others\": map[string]interface{}{},\n\t\t\"standards\": map[string]interface{}{\n\t\t\t\"field1\": map[string]interface{}{\n\t\t\t\t\"name\":        \"field1\",\n\t\t\t\t\"case_sensitive\": true,\n\t\t\t\t\"alias\": map[string]interface{}{\n\t\t\t\t\t\"values\": []interface{}{\"alias1\"},\n\t\t\t\t\t\"lowercased_values\": []interface{}{},\n\t\t\t\t},\n\t\t\t},\n\t\t\t\"field2\": map[string]interface{}{\n\t\t\t\t\"name\":        \"field2\",\n\t\t\t\t\"case_sensitive\": false,\n\t\t\t\t\"alias\": map[string]interface{}{\n\t\t\t\t\t\"values\": []interface{}{\"invalid_alias\"},\n\t\t\t\t\t\"lowercased_values\": []interface{}{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := i.FromMap(m); err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n}\n\nfunc TestFieldMap_FromMap_InvalidCaseSensitive(t *testing.T) {\n\ti := \u0026FieldMapT{}\n\tm := map[string]interface{}{\n\t\t\"others\": map[string]interface{}{},\n\t\t\"standards\": map[string]interface{}{\n\t\t\t\"field1\": map[string]interface{}{\n\t\t\t\t\"name\":        \"field1\",\n\t\t\t\t\"case_sensitive\": \"invalid_value\",\n\t\t\t\t\"alias\": map[string]interface{}{\n\t\t\t\t\t\"values\": []interface{}{\"alias1\"},\n\t\t\t\t\t\"lowercased_values\": []interface{}{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif err := i.FromMap(m); err == nil {\n\t\tt.Errorf(\"Expected error, got none\")\n\t}\n}\n",
    "amount_of_generated_test_cases": 10,
    "single_test_run_command": "go test -v config/field_map_test.go"
}