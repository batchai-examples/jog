{
    "path": "config/compress_prefix.go",
    "model_usage_metrics": {
        "Duration": 20297867939,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "config/compress_prefix_test.go",
    "existing_test_code": "",
    "original_code": "package config\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/gookit/goutil/strutil\"\n\t\"github.com/qiangyt/jog/util\"\n\t\"gopkg.in/yaml.v2\"\n)\n\n// CompressPrefixAction ...\ntype CompressPrefixAction int\n\nconst (\n\t// CompressPrefixActionRemoveNonFirstLetter ...\n\tCompressPrefixActionRemoveNonFirstLetter CompressPrefixAction = iota\n\n\t// CompressPrefixActionRemove ...\n\tCompressPrefixActionRemove\n\n\t// CompressPrefixActionDefault ...\n\tCompressPrefixActionDefault = CompressPrefixActionRemoveNonFirstLetter\n)\n\n// Format ...\nfunc (i CompressPrefixAction) String() string {\n\tif i == CompressPrefixActionRemoveNonFirstLetter {\n\t\treturn \"remove-non-first-letter\"\n\t}\n\tif i == CompressPrefixActionRemove {\n\t\treturn \"remove\"\n\t}\n\n\treturn \"\"\n}\n\n// ParseCompressPrefixAction ...\nfunc ParseCompressPrefixAction(text string) CompressPrefixAction {\n\tif \"remove-non-first-letter\" == text {\n\t\treturn CompressPrefixActionRemoveNonFirstLetter\n\t}\n\tif \"remove\" == text {\n\t\treturn CompressPrefixActionRemove\n\t}\n\n\tpanic(fmt.Errorf(\"unknown CompressPrefixAction text: %v\", text))\n}\n\n// CompressPrefixT ...\ntype CompressPrefixT struct {\n\tyaml.Unmarshaler\n\tyaml.Marshaler\n\n\tEnabled    bool\n\tSeparators StringSet\n\tWhiteList  StringSet\n\tAction     CompressPrefixAction\n}\n\n// CompressPrefix ..\ntype CompressPrefix = *CompressPrefixT\n\n// UnmarshalYAML ...\nfunc (i CompressPrefix) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\treturn UnmarshalYAML(i, unmarshal)\n}\n\n// MarshalYAML ...\nfunc (i CompressPrefix) MarshalYAML() (interface{}, error) {\n\treturn MarshalYAML(i)\n}\n\n// Init ...\nfunc (i CompressPrefix) Init(cfg Configuration) {\n\n}\n\n// FromMap ...\nfunc (i CompressPrefix) FromMap(m map[string]interface{}) error {\n\n\tenabledV := util.ExtractFromMap(m, \"enabled\")\n\tif enabledV != nil {\n\t\ti.Enabled = util.ToBool(enabledV)\n\t}\n\n\tseparatorsV := util.ExtractFromMap(m, \"separators\")\n\tif separatorsV != nil {\n\t\ti.Separators.Parse(separatorsV)\n\t}\n\n\twhiteListV := util.ExtractFromMap(m, \"white-list\")\n\tif whiteListV != nil {\n\t\ti.WhiteList.Parse(whiteListV)\n\t}\n\n\tactionV := util.ExtractFromMap(m, \"action\")\n\tif actionV != nil {\n\t\ti.Action = ParseCompressPrefixAction(strutil.MustString(actionV))\n\t}\n\n\treturn nil\n}\n\n// ToMap ...\nfunc (i CompressPrefix) ToMap() map[string]interface{} {\n\tr := make(map[string]interface{})\n\tr[\"enabled\"] = i.Enabled\n\tr[\"separators\"] = i.Separators.String()\n\tr[\"white-list\"] = i.WhiteList.String()\n\tr[\"action\"] = i.Action.String()\n\treturn r\n}\n\n// Reset ...\nfunc (i CompressPrefix) Reset() {\n\ti.Enabled = false\n\ti.Separators = \u0026StringSetT{}\n\ti.WhiteList = \u0026StringSetT{}\n\ti.Action = CompressPrefixActionDefault\n}\n\n// TODO: this 2 caches are not thread-safe, should be moved to a context\nvar _compressCache4RemoveNonFirstLetter = make(map[string]string)\nvar _compressCache4Remove = make(map[string]string)\n\nfunc (i CompressPrefix) detectSeparator(text string) (string, []string) {\n\tfor separator := range i.Separators.ValueMap {\n\t\tseparated := strings.Split(text, separator)\n\t\tif len(separated) \u003e 1 {\n\t\t\treturn separator, separated\n\t\t}\n\t}\n\n\tif i.Separators.CaseSensitive == false {\n\t\tfor separator := range i.Separators.LowercasedValueMap {\n\t\t\tseparated := strings.Split(text, separator)\n\t\t\tif len(separated) \u003e 1 {\n\t\t\t\treturn separator, separated\n\t\t\t}\n\t\t}\n\t\tfor separator := range i.Separators.UppercasedValueMap {\n\t\t\tseparated := strings.Split(text, separator)\n\t\t\tif len(separated) \u003e 1 {\n\t\t\t\treturn separator, separated\n\t\t\t}\n\t\t}\n\t}\n\n\treturn \"\", []string{text}\n}\n\n// Compress ...\nfunc (i CompressPrefix) Compress(text string) string {\n\tif i.Action == CompressPrefixActionRemoveNonFirstLetter {\n\t\tif existingOne, ok := _compressCache4RemoveNonFirstLetter[text]; ok {\n\t\t\treturn existingOne\n\t\t}\n\n\t\tvar r string\n\t\tif i.WhiteList.ContainsPrefixOf(text) {\n\t\t\tr = text\n\t\t} else {\n\t\t\tseparator, separated := i.detectSeparator(text)\n\n\t\t\tif len(separated) \u003e 1 {\n\t\t\t\tindexOfLast := len(separated) - 1\n\t\t\t\tfor index, item := range separated[:indexOfLast] {\n\t\t\t\t\tseparated[index] = string([]byte(item)[0])\n\t\t\t\t}\n\n\t\t\t\tr = strings.Join(separated, separator)\n\t\t\t} else {\n\t\t\t\tr = text\n\t\t\t}\n\t\t}\n\n\t\t_compressCache4RemoveNonFirstLetter[text] = r\n\t\treturn r\n\t}\n\n\tif i.Action == CompressPrefixActionRemove {\n\t\tif existingOne, ok := _compressCache4Remove[text]; ok {\n\t\t\treturn existingOne\n\t\t}\n\n\t\tvar r string\n\t\tif i.WhiteList.ContainsPrefixOf(text) {\n\t\t\tr = text\n\t\t} else {\n\t\t\t_, separated := i.detectSeparator(text)\n\n\t\t\tif len(separated) \u003e 1 {\n\t\t\t\tr = separated[len(separated)-1]\n\t\t\t} else {\n\t\t\t\tr = text\n\t\t\t}\n\t\t}\n\t\t_compressCache4Remove[text] = r\n\t\treturn r\n\t}\n\n\treturn text\n}\n",
    "test_code": "package config\n\nimport (\n\t\"testing\"\n)\n\nfunc TestCompressPrefixActionString(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    CompressPrefixAction\n\t\texpected string\n\t}{\n\t\t{\"RemoveNonFirstLetter\", CompressPrefixActionRemoveNonFirstLetter, \"remove-non-first-letter\"},\n\t\t{\"Remove\", CompressPrefixActionRemove, \"remove\"},\n\t\t{\"Default\", CompressPrefixActionDefault, \"remove-non-first-letter\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.String()\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %s, got %s\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseCompressPrefixAction(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected CompressPrefixAction\n\t}{\n\t\t{\"RemoveNonFirstLetter\", \"remove-non-first-letter\", CompressPrefixActionRemoveNonFirstLetter},\n\t\t{\"Remove\", \"remove\", CompressPrefixActionRemove},\n\t\t{\"Unknown\", \"unknown\", CompressPrefixActionDefault},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := ParseCompressPrefixAction(tc.input)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCompressPrefixT_Init(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    CompressPrefixT\n\t\texpected CompressPrefixT\n\t}{\n\t\t{\"Default\", CompressPrefixT{}, CompressPrefixT{Enabled: false, Separators: StringSet{}, WhiteList: StringSet{}, Action: CompressPrefixActionDefault}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttc.input.Init(Configuration{})\n\t\t\tif tc.input.Enabled != tc.expected.Enabled || !tc.input.Separators.Equal(\u0026tc.expected.Separators) || !tc.input.WhiteList.Equal(\u0026tc.expected.WhiteList) || tc.input.Action != tc.expected.Action {\n\t\t\t\tt.Errorf(\"Expected %+v, got %+v\", tc.expected, tc.input)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCompressPrefixT_FromMap(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    CompressPrefixT\n\t\tdata     map[string]interface{}\n\t\texpected CompressPrefixT\n\t}{\n\t\t{\"Default\", CompressPrefixT{}, map[string]interface{}{}, CompressPrefixT{Enabled: false, Separators: StringSet{}, WhiteList: StringSet{}, Action: CompressPrefixActionDefault}},\n\t\t{\"WithValues\", CompressPrefixT{}, map[string]interface{}{\n\t\t\t\"enabled\": true,\n\t\t\t\"separators\": []string{\n\t\t\t\t\"-\",\n\t\t\t\t\"_\",\n\t\t\t},\n\t\t\t\"white_list\": []string{\n\t\t\t\t\"prefix1\",\n\t\t\t\t\"prefix2\",\n\t\t\t},\n\t\t\t\"action\": \"remove\",\n\t\t}, CompressPrefixT{Enabled: true, Separators: StringSet{\"-\": struct{}{}, \"_\": struct{}{}}, WhiteList: StringSet{\"prefix1\": struct{}{}, \"prefix2\": struct{}{}}, Action: CompressPrefixActionRemove}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\terr := tc.input.FromMap(tc.data)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t\t\t}\n\t\t\tif tc.input.Enabled != tc.expected.Enabled || !tc.input.Separators.Equal(\u0026tc.expected.Separators) || !tc.input.WhiteList.Equal(\u0026tc.expected.WhiteList) || tc.input.Action != tc.expected.Action {\n\t\t\t\tt.Errorf(\"Expected %+v, got %+v\", tc.expected, tc.input)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCompressPrefixT_Compress(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    CompressPrefixT\n\t\ttext     string\n\t\texpected string\n\t}{\n\t\t{\"RemoveNonFirstLetter\", CompressPrefixT{Action: CompressPrefixActionRemoveNonFirstLetter}, \"hello-world\", \"h-w\"},\n\t\t{\"Remove\", CompressPrefixT{Action: CompressPrefixActionRemove}, \"hello-world\", \"world\"},\n\t\t{\"NoAction\", CompressPrefixT{}, \"hello-world\", \"hello-world\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Compress(tc.text)\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %s, got %s\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "amount_of_generated_test_cases": 10,
    "single_test_run_command": "go test -v config/compress_prefix_test.go"
}