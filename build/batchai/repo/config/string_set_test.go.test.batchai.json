{
    "path": "config/string_set_test.go",
    "model_usage_metrics": {
        "Duration": 15576370650,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "config/string_set_test.go",
    "existing_test_code": "",
    "original_code": "package config\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestStringSet_Parse(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    interface{}\n\t\texpected map[string]bool\n\t}{\n\t\t{\n\t\t\tinput:    []string{\"apple\", \"banana\", \"cherry\"},\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tinput:    \"apple, banana, cherry\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tinput:    []string{},\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tinput:    123,\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"InputType=%T\", tc.input), func(t *testing.T) {\n\t\t\tset := \u0026StringSetT{CaseSensitive: true}\n\t\t\tset.Parse(tc.input)\n\t\t\tassert.Equal(t, tc.expected, set.ValueMap)\n\t\t})\n\t}\n}\n\nfunc TestStringSet_Reset(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\tset.Reset()\n\tassert.Empty(t, set.ValueMap)\n}\n\nfunc TestStringSet_IsEmpty(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    StringSet\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    \u0026StringSetT{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    \u0026StringSetT{ValueMap: map[string]bool{\"apple\": true}},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Input=%v\", tc.input), func(t *testing.T) {\n\t\t\tassert.Equal(t, tc.expected, tc.input.IsEmpty())\n\t\t})\n\t}\n}\n\nfunc TestStringSet_Contains(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    \"apple\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"Banana\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"cherry\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Input=%s\", tc.input), func(t *testing.T) {\n\t\t\tassert.Equal(t, tc.expected, set.Contains(tc.input))\n\t\t})\n\t}\n}\n\nfunc TestStringSet_ContainsPrefixOf(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    \"app\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"Banana\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"cherry\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Input=%s\", tc.input), func(t *testing.T) {\n\t\t\tassert.Equal(t, tc.expected, set.ContainsPrefixOf(tc.input))\n\t\t})\n\t}\n}\n\nfunc TestStringSet_String(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\texpected := \"apple, banana\"\n\tresult := set.String()\n\tassert.Equal(t, expected, result)\n}\n\nfunc TestStringSet_UnmarshalYAML(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    interface{}\n\t\texpected map[string]bool\n\t}{\n\t\t{\n\t\t\tinput:    []string{\"apple\", \"banana\", \"cherry\"},\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tinput:    \"apple, banana, cherry\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tinput:    []string{},\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tinput:    123,\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"InputType=%T\", tc.input), func(t *testing.T) {\n\t\t\tset := \u0026StringSetT{CaseSensitive: true}\n\t\t\terr := set.UnmarshalYAML(func(interface{}) error {\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\t\t\tset.Parse(tc.input)\n\t\t\tassert.Equal(t, tc.expected, set.ValueMap)\n\t\t})\n\t}\n}\n\nfunc TestStringSet_MarshalYAML(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\texpected := []interface{}{\"apple\", \"banana\"}\n\tresult, err := set.MarshalYAML()\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, result)\n}\n",
    "test_code": "package config\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestStringSet_Parse_HappyPath(t *testing.T) {\n\tset := \u0026StringSetT{CaseSensitive: true}\n\tset.Parse([]string{\"apple\", \"banana\", \"cherry\"})\n\tassert.Equal(t, map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true}, set.ValueMap)\n}\n\nfunc TestStringSet_Parse_EmptyInput(t *testing.T) {\n\tset := \u0026StringSetT{CaseSensitive: true}\n\tset.Parse(\"\")\n\tassert.Empty(t, set.ValueMap)\n}\n\nfunc TestStringSet_Parse_InvalidInput(t *testing.T) {\n\tset := \u0026StringSetT{CaseSensitive: true}\n\tset.Parse(123)\n\tassert.Empty(t, set.ValueMap)\n}\n\nfunc TestStringSet_Reset_HappyPath(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\tset.Reset()\n\tassert.Empty(t, set.ValueMap)\n}\n\nfunc TestStringSet_IsEmpty_EmptySet(t *testing.T) {\n\tset := \u0026StringSetT{}\n\tassert.True(t, set.IsEmpty())\n}\n\nfunc TestStringSet_IsEmpty_NonEmptySet(t *testing.T) {\n\tset := \u0026StringSetT{ValueMap: map[string]bool{\"apple\": true}}\n\tassert.False(t, set.IsEmpty())\n}\n\nfunc TestStringSet_Contains_HappyPath(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\tassert.True(t, set.Contains(\"apple\"))\n\tassert.False(t, set.Contains(\"Banana\"))\n}\n\nfunc TestStringSet_Contains_CaseSensitive(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t\tCaseSensitive: true,\n\t}\n\tassert.True(t, set.Contains(\"apple\"))\n\tassert.False(t, set.Contains(\"Banana\"))\n}\n\nfunc TestStringSet_ContainsPrefixOf_HappyPath(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\tassert.True(t, set.ContainsPrefixOf(\"app\"))\n\tassert.False(t, set.ContainsPrefixOf(\"Banana\"))\n}\n\nfunc TestStringSet_ContainsPrefixOf_CaseSensitive(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t\tCaseSensitive: true,\n\t}\n\tassert.True(t, set.ContainsPrefixOf(\"app\"))\n\tassert.False(t, set.ContainsPrefixOf(\"Banana\"))\n}\n\nfunc TestStringSet_String_HappyPath(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\tresult := set.String()\n\tassert.Equal(t, \"apple, banana\", result)\n}\n\nfunc TestStringSet_UnmarshalYAML_HappyPath(t *testing.T) {\n\tset := \u0026StringSetT{CaseSensitive: true}\n\terr := set.UnmarshalYAML(func(interface{}) error {\n\t\treturn nil\n\t})\n\tassert.NoError(t, err)\n\tset.Parse([]string{\"apple\", \"banana\", \"cherry\"})\n\tassert.Equal(t, map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true}, set.ValueMap)\n}\n\nfunc TestStringSet_MarshalYAML_HappyPath(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\tresult, err := set.MarshalYAML()\n\tassert.NoError(t, err)\n\tassert.Equal(t, []interface{}{\"apple\", \"banana\"}, result)\n}\n",
    "amount_of_generated_test_cases": 14,
    "single_test_run_command": "go test -v config/string_set_test.go"
}