{
    "path": "config/field.go",
    "model_usage_metrics": {
        "Duration": 25423560620,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "config/field_test.go",
    "existing_test_code": "",
    "original_code": "package config\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/gookit/goutil/strutil\"\n\t\"github.com/qiangyt/jog/util\"\n)\n\n// FieldType ...\ntype FieldType int\n\nconst (\n\t// FieldTypeAuto ...\n\tFieldTypeAuto FieldType = iota\n\n\t// FieldTypeTime ...\n\tFieldTypeTime\n)\n\n// FieldT ...\ntype FieldT struct {\n\tElementT\n\n\tName           string\n\tAlias          util.MultiString\n\tCaseSensitive  bool `yaml:\"case-sensitive\"`\n\tCompressPrefix `yaml:\"compress-prefix\"`\n\tEnums          EnumMap\n\tType           FieldType\n\tTimeFormat     string `yaml:\"time-format\"`\n\tTimezone       string `yaml:\"timezone\"`\n\tTimeLocation   *time.Location\n}\n\n// Field ...\ntype Field = *FieldT\n\n// Reset ...\nfunc (i Field) Reset() {\n\ti.ElementT.Reset()\n\n\ti.Name = \"\"\n\n\ti.Alias = \u0026util.MultiStringT{}\n\ti.Alias.Set(\"\")\n\n\ti.CaseSensitive = false\n\n\ti.CompressPrefix = \u0026CompressPrefixT{}\n\ti.CompressPrefix.Reset()\n\n\ti.Enums = \u0026EnumMapT{}\n\ti.Enums.Reset()\n\n\ti.Type = FieldTypeAuto\n\ti.TimeFormat = \"\"\n\ti.Timezone = \"\"\n\ti.TimeLocation = nil\n}\n\n// UnmarshalYAML ...\nfunc (i Field) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\te := UnmarshalYAML(i, unmarshal)\n\treturn e\n}\n\n// MarshalYAML ...\nfunc (i Field) MarshalYAML() (interface{}, error) {\n\treturn MarshalYAML(i)\n}\n\n// Init ...\nfunc (i Field) Init(cfg Configuration) {\n}\n\n// IsEnum ...\nfunc (i Field) IsEnum() bool {\n\treturn !i.Enums.IsEmpty()\n}\n\n// ToMap ...\nfunc (i Field) ToMap() map[string]interface{} {\n\tr := i.ElementT.ToMap()\n\n\tr[\"case-sensitive\"] = i.CaseSensitive\n\tr[\"alias\"] = i.Alias.String()\n\tr[\"compress-prefix\"] = i.CompressPrefix.ToMap()\n\tif i.IsEnum() {\n\t\tr[\"enums\"] = i.Enums.ToMap()\n\t}\n\n\tif i.Type != FieldTypeAuto {\n\t\tif i.Type == FieldTypeTime {\n\t\t\tr[\"type\"] = \"time\"\n\t\t}\n\t}\n\n\tif len(i.TimeFormat) \u003e 0 {\n\t\tr[\"time-format\"] = i.TimeFormat\n\t}\n\n\tif len(i.Timezone) \u003e 0 {\n\t\tr[\"timezone\"] = i.Timezone\n\t}\n\n\treturn r\n}\n\n// FromMap ...\nfunc (i Field) FromMap(m map[string]interface{}) error {\n\tif err := i.ElementT.FromMap(m); err != nil {\n\t\treturn err\n\t}\n\n\tcaseSensitiveV := util.ExtractFromMap(m, \"case-sensitive\")\n\tif caseSensitiveV != nil {\n\t\ti.CaseSensitive = util.ToBool(caseSensitiveV)\n\t}\n\n\taliasV := util.ExtractFromMap(m, \"alias\")\n\tif aliasV != nil {\n\t\ti.Alias.Set(strutil.MustString(aliasV))\n\t}\n\n\tcompressPrefixV := util.ExtractFromMap(m, \"compress-prefix\")\n\tif compressPrefixV != nil {\n\t\tif err := util.UnmashalYAMLAgain(compressPrefixV, \u0026i.CompressPrefix); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tenumsV := util.ExtractFromMap(m, \"enums\")\n\tif enumsV != nil {\n\t\tif err := util.UnmashalYAMLAgain(enumsV, \u0026i.Enums); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ttypeV := util.ExtractFromMap(m, \"type\")\n\tif typeV != nil {\n\t\ttypeT := strutil.MustString(typeV)\n\t\tif typeT == \"time\" {\n\t\t\ti.Type = FieldTypeTime\n\t\t} else if typeT == \"auto\" {\n\t\t\ti.Type = FieldTypeAuto\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"unknown field type: %s\", typeT)\n\t\t}\n\t}\n\n\ttimeFormatV := util.ExtractFromMap(m, \"time-format\")\n\tif timeFormatV != nil {\n\t\ti.TimeFormat = strutil.MustString(timeFormatV)\n\t}\n\n\ttimezoneV := util.ExtractFromMap(m, \"timezone\")\n\tif timezoneV != nil {\n\t\ti.Timezone = strutil.MustString(timezoneV)\n\n\t\tloc, err := time.LoadLocation(i.Timezone)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid timezone: %s\", i.Timezone)\n\t\t}\n\t\ti.TimeLocation = loc\n\t}\n\n\treturn nil\n}\n\n// GetColor ...\nfunc (i Field) GetColor(value string) util.Color {\n\tif i.IsEnum() {\n\t\treturn i.Enums.GetEnum(value).Color\n\t}\n\treturn i.Color\n}\n",
    "test_code": "package config\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestField_Reset(t *testing.T) {\n\tfield := \u0026FieldT{\n\t\tName:           \"test\",\n\t\tAlias:          util.NewMultiString(\"alias1\", \"alias2\"),\n\t\tCaseSensitive:  true,\n\t\tTimeFormat:     \"2006-01-02\",\n\t\tTimezone:       \"UTC\",\n\t\tType:           FieldTypeTime,\n\t}\n\n\tfield.Reset()\n\n\tassert.Equal(t, \"\", field.Name)\n\tassert.Equal(t, util.NewMultiString(\"\"), field.Alias)\n\tassert.False(t, field.CaseSensitive)\n\tassert.Equal(t, \u0026CompressPrefixT{}, field.CompressPrefix)\n\tassert.Equal(t, \u0026EnumMapT{}, field.Enums)\n\tassert.Equal(t, FieldTypeAuto, field.Type)\n\tassert.Equal(t, \"\", field.TimeFormat)\n\tassert.Equal(t, \"\", field.Timezone)\n\tassert.Nil(t, field.TimeLocation)\n}\n\nfunc TestField_UnmarshalYAML_HappyPath(t *testing.T) {\n\tfield := \u0026FieldT{}\n\terr := field.UnmarshalYAML(func(interface{}) error { return nil })\n\tassert.NoError(t, err)\n\n\tfield = \u0026FieldT{}\n\terr = field.UnmarshalYAML(func(interface{}) error {\n\t\treturn fmt.Errorf(\"error unmarshalling YAML\")\n\t})\n\tassert.Error(t, err)\n}\n\nfunc TestField_MarshalYAML_HappyPath(t *testing.T) {\n\tfield := \u0026FieldT{\n\t\tName:           \"test\",\n\t\tAlias:          util.NewMultiString(\"alias1\", \"alias2\"),\n\t\tCaseSensitive:  true,\n\t\tTimeFormat:     \"2006-01-02\",\n\t\tTimezone:       \"UTC\",\n\t\tType:           FieldTypeTime,\n\t}\n\n\tresult, err := field.MarshalYAML()\n\tassert.NoError(t, err)\n\tassert.NotNil(t, result)\n\n\tfield = \u0026FieldT{}\n\tresult, err = field.MarshalYAML()\n\tassert.NoError(t, err)\n\tassert.Nil(t, result)\n}\n\nfunc TestField_Init_HappyPath(t *testing.T) {\n\tfield := \u0026FieldT{}\n\tcfg := Configuration{}\n\tfield.Init(cfg)\n\n\t// Add more assertions as needed\n}\n\nfunc TestField_IsEnum_HappyPath(t *testing.T) {\n\tfield := \u0026FieldT{\n\t\tEnums: \u0026EnumMapT{},\n\t}\n\tassert.True(t, field.IsEnum())\n\n\tfield = \u0026FieldT{}\n\tassert.False(t, field.IsEnum())\n}\n\nfunc TestField_ToMap_HappyPath(t *testing.T) {\n\tfield := \u0026FieldT{\n\t\tName:           \"test\",\n\t\tAlias:          util.NewMultiString(\"alias1\", \"alias2\"),\n\t\tCaseSensitive:  true,\n\t\tTimeFormat:     \"2006-01-02\",\n\t\tTimezone:       \"UTC\",\n\t\tType:           FieldTypeTime,\n\t}\n\n\tresult := field.ToMap()\n\tassert.Equal(t, map[string]interface{}{\n\t\t\"name\":         \"test\",\n\t\t\"alias\":        []interface{}{\"alias1\", \"alias2\"},\n\t\t\"case-sensitive\": true,\n\t\t\"type\":         \"time\",\n\t\t\"time-format\":  \"2006-01-02\",\n\t\t\"timezone\":     \"UTC\",\n\t}, result)\n\n\tfield = \u0026FieldT{}\n\tresult = field.ToMap()\n\tassert.Equal(t, map[string]interface{}{\n\t\t\"name\":         \"\",\n\t\t\"alias\":        []interface{}{},\n\t\t\"case-sensitive\": false,\n\t\t\"type\":         \"auto\",\n\t}, result)\n}\n\nfunc TestField_FromMap_HappyPath(t *testing.T) {\n\tfield := \u0026FieldT{}\n\tm := map[string]interface{}{\n\t\t\"name\":         \"test\",\n\t\t\"alias\":        []interface{}{\"alias1\", \"alias2\"},\n\t\t\"case-sensitive\": true,\n\t\t\"type\":         \"time\",\n\t\t\"time-format\":  \"2006-01-02\",\n\t\t\"timezone\":     \"UTC\",\n\t}\n\terr := field.FromMap(m)\n\tassert.NoError(t, err)\n\n\tfield = \u0026FieldT{}\n\tm = map[string]interface{}{\n\t\t\"name\":         \"\",\n\t\t\"alias\":        []interface{}{},\n\t\t\"case-sensitive\": false,\n\t\t\"type\":         \"auto\",\n\t}\n\terr = field.FromMap(m)\n\tassert.NoError(t, err)\n\n\tfield = \u0026FieldT{}\n\tm = map[string]interface{}{\n\t\t\"name\":         \"test\",\n\t\t\"alias\":        []interface{}{\"alias1\", \"alias2\"},\n\t\t\"case-sensitive\": true,\n\t\t\"type\":         \"unknown\",\n\t}\n\terr = field.FromMap(m)\n\tassert.Error(t, err)\n\n\tfield = \u0026FieldT{}\n\tm = map[string]interface{}{\n\t\t\"name\":         \"test\",\n\t\t\"alias\":        []interface{}{\"alias1\", \"alias2\"},\n\t\t\"case-sensitive\": true,\n\t\t\"time-format\":  \"invalid\",\n\t}\n\terr = field.FromMap(m)\n\tassert.Error(t, err)\n\n\tfield = \u0026FieldT{}\n\tm = map[string]interface{}{\n\t\t\"name\":         \"test\",\n\t\t\"alias\":        []interface{}{\"alias1\", \"alias2\"},\n\t\t\"case-sensitive\": true,\n\t\t\"timezone\":     \"invalid\",\n\t}\n\terr = field.FromMap(m)\n\tassert.Error(t, err)\n}\n\nfunc TestField_GetColor_HappyPath(t *testing.T) {\n\tfield := \u0026FieldT{\n\t\tEnums: \u0026EnumMapT{},\n\t}\n\tcolor := field.GetColor(\"value\")\n\tassert.Equal(t, util.Color{}, color)\n\n\tfield = \u0026FieldT{}\n\tcolor = field.GetColor(\"value\")\n\tassert.Equal(t, util.Color{}, color)\n}\n\nfunc TestField_GetColor_WithEnum(t *testing.T) {\n\tfield := \u0026FieldT{\n\t\tEnums: \u0026EnumMapT{\n\t\t\tMap: map[string]*Enum{\n\t\t\t\t\"value\": \u0026Enum{\n\t\t\t\t\tColor: util.Color{R: 255, G: 0, B: 0},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tcolor := field.GetColor(\"value\")\n\tassert.Equal(t, util.Color{R: 255, G: 0, B: 0}, color)\n}\n\nfunc TestField_GetColor_WithNoEnum(t *testing.T) {\n\tfield := \u0026FieldT{}\n\tcolor := field.GetColor(\"value\")\n\tassert.Equal(t, util.Color{}, color)\n}\n",
    "amount_of_generated_test_cases": 10,
    "single_test_run_command": "go test -v config/field_test.go"
}