{
    "path": "config/string_set.go",
    "model_usage_metrics": {
        "Duration": 23790552362,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "config/string_set_test.go",
    "existing_test_code": "",
    "original_code": "package config\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/gookit/goutil/strutil\"\n\t\"gopkg.in/yaml.v2\"\n)\n\n// StringSetT ...\ntype StringSetT struct {\n\tyaml.Unmarshaler\n\tyaml.Marshaler\n\n\tCaseSensitive      bool\n\tValueMap           map[string]bool\n\tLowercasedValueMap map[string]bool\n\tUppercasedValueMap map[string]bool\n}\n\n// StringSet ...\ntype StringSet = *StringSetT\n\n// Parse ...\nfunc (i StringSet) Parse(input interface{}) {\n\ti.Reset()\n\n\tvar valuesArray []string\n\n\tswitch input.(type) {\n\tcase []string:\n\t\t{\n\t\t\tvaluesArray = input.([]string)\n\t\t}\n\tcase string:\n\t\t{\n\t\t\tvaluesArray = strutil.Split(input.(string), \",\")\n\t\t}\n\tdefault:\n\t\tpanic(fmt.Errorf(\"not a string array: %v\", input))\n\t}\n\n\tfor _, v := range valuesArray {\n\t\tv = strings.Trim(v, \"\\t\\r\\n \")\n\t\ti.ValueMap[v] = true\n\t\tif i.CaseSensitive == false {\n\t\t\ti.LowercasedValueMap[strings.ToLower(v)] = true\n\t\t\ti.UppercasedValueMap[strings.ToUpper(v)] = true\n\t\t}\n\t}\n}\n\n// Reset ...\nfunc (i StringSet) Reset() {\n\ti.ValueMap = make(map[string]bool)\n\ti.LowercasedValueMap = make(map[string]bool)\n\ti.UppercasedValueMap = make(map[string]bool)\n}\n\nfunc (i StringSet) IsEmpty() bool {\n\treturn i.ValueMap == nil || len(i.ValueMap) == 0\n}\n\n// Contains ...\nfunc (i StringSet) Contains(v string) bool {\n\tr := i.ValueMap[v]\n\tif r {\n\t\treturn true\n\t}\n\tif i.CaseSensitive == false {\n\t\treturn i.LowercasedValueMap[strings.ToLower(v)]\n\t}\n\treturn false\n}\n\n// ContainsPrefixOf ...\nfunc (i StringSet) ContainsPrefixOf(v string) bool {\n\tif len(i.ValueMap) == 0 {\n\t\treturn false\n\t}\n\n\tfor prefix := range i.ValueMap {\n\t\tif strings.HasPrefix(v, prefix) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif i.CaseSensitive == false {\n\t\tvar lowercasedV = strings.ToLower(v)\n\t\tfor prefix := range i.LowercasedValueMap {\n\t\t\tif strings.HasPrefix(lowercasedV, prefix) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc (i StringSet) String() string {\n\tbuf := \u0026strings.Builder{}\n\n\tfirst := true\n\tfor v := range i.ValueMap {\n\t\tif first {\n\t\t\tfirst = false\n\t\t} else {\n\t\t\tbuf.WriteString(\", \")\n\t\t}\n\t\tbuf.WriteString(v)\n\t}\n\treturn buf.String()\n}\n\n// UnmarshalYAML ...\nfunc (i StringSet) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar input interface{}\n\terr := unmarshal(\u0026input)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ti.Parse(input)\n\n\treturn nil\n}\n\n// MarshalYAML ...\nfunc (i StringSet) MarshalYAML() (interface{}, error) {\n\treturn i.String(), nil\n}\n",
    "test_code": "package config\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestStringSet_Parse(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    interface{}\n\t\texpected map[string]bool\n\t}{\n\t\t{\n\t\t\tinput:    []string{\"apple\", \"banana\", \"cherry\"},\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tinput:    \"apple, banana, cherry\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tinput:    []string{},\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tinput:    123,\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"InputType=%T\", tc.input), func(t *testing.T) {\n\t\t\tset := \u0026StringSetT{CaseSensitive: true}\n\t\t\tset.Parse(tc.input)\n\t\t\tassert.Equal(t, tc.expected, set.ValueMap)\n\t\t})\n\t}\n}\n\nfunc TestStringSet_Reset(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\tset.Reset()\n\tassert.Empty(t, set.ValueMap)\n}\n\nfunc TestStringSet_IsEmpty(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    StringSet\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    \u0026StringSetT{},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    \u0026StringSetT{ValueMap: map[string]bool{\"apple\": true}},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Input=%v\", tc.input), func(t *testing.T) {\n\t\t\tassert.Equal(t, tc.expected, tc.input.IsEmpty())\n\t\t})\n\t}\n}\n\nfunc TestStringSet_Contains(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    \"apple\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"Banana\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"cherry\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Input=%s\", tc.input), func(t *testing.T) {\n\t\t\tassert.Equal(t, tc.expected, set.Contains(tc.input))\n\t\t})\n\t}\n}\n\nfunc TestStringSet_ContainsPrefixOf(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    \"app\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    \"Banana\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    \"cherry\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"Input=%s\", tc.input), func(t *testing.T) {\n\t\t\tassert.Equal(t, tc.expected, set.ContainsPrefixOf(tc.input))\n\t\t})\n\t}\n}\n\nfunc TestStringSet_String(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\texpected := \"apple, banana\"\n\tresult := set.String()\n\tassert.Equal(t, expected, result)\n}\n\nfunc TestStringSet_UnmarshalYAML(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    interface{}\n\t\texpected map[string]bool\n\t}{\n\t\t{\n\t\t\tinput:    []string{\"apple\", \"banana\", \"cherry\"},\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tinput:    \"apple, banana, cherry\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tinput:    []string{},\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tinput:    \"\",\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tinput:    123,\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"InputType=%T\", tc.input), func(t *testing.T) {\n\t\t\tset := \u0026StringSetT{CaseSensitive: true}\n\t\t\terr := set.UnmarshalYAML(func(interface{}) error {\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\t\t\tset.Parse(tc.input)\n\t\t\tassert.Equal(t, tc.expected, set.ValueMap)\n\t\t})\n\t}\n}\n\nfunc TestStringSet_MarshalYAML(t *testing.T) {\n\tset := \u0026StringSetT{\n\t\tValueMap: map[string]bool{\"apple\": true, \"banana\": true},\n\t}\n\n\texpected := []interface{}{\"apple\", \"banana\"}\n\tresult, err := set.MarshalYAML()\n\tassert.NoError(t, err)\n\tassert.Equal(t, expected, result)\n}\n",
    "amount_of_generated_test_cases": 12,
    "single_test_run_command": "go test -v config/string_set_test.go"
}