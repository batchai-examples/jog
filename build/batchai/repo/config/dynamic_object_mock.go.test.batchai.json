{
    "path": "config/dynamic_object_mock.go",
    "model_usage_metrics": {
        "Duration": 18038433955,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "config/dynamic_object_mock_test.go",
    "existing_test_code": "",
    "original_code": "// Code generated by MockGen. DO NOT EDIT.\n// Source: ./dynamic_object.go\n\n// Package config is a generated GoMock package.\npackage config\n\nimport (\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n)\n\n// MockDynamicObject is a mock of DynamicObject interface.\ntype MockDynamicObject struct {\n\tctrl     *gomock.Controller\n\trecorder *MockDynamicObjectMockRecorder\n}\n\n// MockDynamicObjectMockRecorder is the mock recorder for MockDynamicObject.\ntype MockDynamicObjectMockRecorder struct {\n\tmock *MockDynamicObject\n}\n\n// NewMockDynamicObject creates a new mock instance.\nfunc NewMockDynamicObject(ctrl *gomock.Controller) *MockDynamicObject {\n\tmock := \u0026MockDynamicObject{ctrl: ctrl}\n\tmock.recorder = \u0026MockDynamicObjectMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockDynamicObject) EXPECT() *MockDynamicObjectMockRecorder {\n\treturn m.recorder\n}\n\n// FromMap mocks base method.\nfunc (m_2 *MockDynamicObject) FromMap(m map[string]interface{}) error {\n\tm_2.ctrl.T.Helper()\n\tret := m_2.ctrl.Call(m_2, \"FromMap\", m)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// FromMap indicates an expected call of FromMap.\nfunc (mr *MockDynamicObjectMockRecorder) FromMap(m interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FromMap\", reflect.TypeOf((*MockDynamicObject)(nil).FromMap), m)\n}\n\n// Init mocks base method.\nfunc (m *MockDynamicObject) Init(cfg Configuration) {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Init\", cfg)\n}\n\n// Init indicates an expected call of Init.\nfunc (mr *MockDynamicObjectMockRecorder) Init(cfg interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Init\", reflect.TypeOf((*MockDynamicObject)(nil).Init), cfg)\n}\n\n// Reset mocks base method.\nfunc (m *MockDynamicObject) Reset() {\n\tm.ctrl.T.Helper()\n\tm.ctrl.Call(m, \"Reset\")\n}\n\n// Reset indicates an expected call of Reset.\nfunc (mr *MockDynamicObjectMockRecorder) Reset() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Reset\", reflect.TypeOf((*MockDynamicObject)(nil).Reset))\n}\n\n// ToMap mocks base method.\nfunc (m *MockDynamicObject) ToMap() map[string]interface{} {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"ToMap\")\n\tret0, _ := ret[0].(map[string]interface{})\n\treturn ret0\n}\n\n// ToMap indicates an expected call of ToMap.\nfunc (mr *MockDynamicObjectMockRecorder) ToMap() *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"ToMap\", reflect.TypeOf((*MockDynamicObject)(nil).ToMap))\n}\n",
    "test_code": "package config\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/golang/mock/gomock\"\n)\n\nfunc TestMockDynamicObject_FromMap_HappyPath(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockObj := NewMockDynamicObject(ctrl)\n\tmockRecorder := mockObj.EXPECT()\n\n\ttestMap := map[string]interface{}{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": 42,\n\t}\n\n\tmockRecorder.FromMap(testMap).Return(nil)\n\n\terr := mockObj.FromMap(testMap)\n\tif err != nil {\n\t\tt.Errorf(\"Expected no error, but got: %v\", err)\n\t}\n}\n\nfunc TestMockDynamicObject_FromMap_NegativePath(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockObj := NewMockDynamicObject(ctrl)\n\tmockRecorder := mockObj.EXPECT()\n\n\ttestMap := map[string]interface{}{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": 42,\n\t}\n\n\texpectedErr := errors.New(\"test error\")\n\tmockRecorder.FromMap(testMap).Return(expectedErr)\n\n\terr := mockObj.FromMap(testMap)\n\tif err == nil {\n\t\tt.Errorf(\"Expected an error, but got none\")\n\t} else if err != expectedErr {\n\t\tt.Errorf(\"Expected error %v, but got %v\", expectedErr, err)\n\t}\n}\n\nfunc TestMockDynamicObject_Init_HappyPath(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockObj := NewMockDynamicObject(ctrl)\n\tmockRecorder := mockObj.EXPECT()\n\n\ttestConfig := Configuration{}\n\n\tmockRecorder.Init(testConfig)\n\n\tmockObj.Init(testConfig)\n}\n\nfunc TestMockDynamicObject_Reset_HappyPath(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockObj := NewMockDynamicObject(ctrl)\n\tmockRecorder := mockObj.EXPECT()\n\n\tmockRecorder.Reset()\n\n\tmockObj.Reset()\n}\n\nfunc TestMockDynamicObject_ToMap_HappyPath(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockObj := NewMockDynamicObject(ctrl)\n\tmockRecorder := mockObj.EXPECT()\n\n\texpectedMap := map[string]interface{}{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": 42,\n\t}\n\n\tmockRecorder.ToMap().Return(expectedMap)\n\n\tresult := mockObj.ToMap()\n\tif !reflect.DeepEqual(result, expectedMap) {\n\t\tt.Errorf(\"Expected map %v, but got %v\", expectedMap, result)\n\t}\n}\n\nfunc TestMockDynamicObject_ToMap_NegativePath(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockObj := NewMockDynamicObject(ctrl)\n\tmockRecorder := mockObj.EXPECT()\n\n\texpectedMap := map[string]interface{}{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": 42,\n\t}\n\n\tmockRecorder.ToMap().Return(nil)\n\n\tresult := mockObj.ToMap()\n\tif result != nil {\n\t\tt.Errorf(\"Expected nil, but got %v\", result)\n\t}\n}\n\nfunc TestMockDynamicObject_FromMap_CornerCase(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockObj := NewMockDynamicObject(ctrl)\n\tmockRecorder := mockObj.EXPECT()\n\n\ttestMap := map[string]interface{}{\n\t\t\"key1\": \"value1\",\n\t\t\"key2\": 42,\n\t}\n\n\texpectedErr := errors.New(\"test error\")\n\tmockRecorder.FromMap(testMap).Return(expectedErr)\n\n\terr := mockObj.FromMap(testMap)\n\tif err == nil {\n\t\tt.Errorf(\"Expected an error, but got none\")\n\t} else if err != expectedErr {\n\t\tt.Errorf(\"Expected error %v, but got %v\", expectedErr, err)\n\t}\n}\n\nfunc TestMockDynamicObject_Init_CornerCase(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockObj := NewMockDynamicObject(ctrl)\n\tmockRecorder := mockObj.EXPECT()\n\n\ttestConfig := Configuration{}\n\n\tmockRecorder.Init(testConfig)\n\n\tmockObj.Init(testConfig)\n}\n\nfunc TestMockDynamicObject_Reset_CornerCase(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tdefer ctrl.Finish()\n\n\tmockObj := NewMockDynamicObject(ctrl)\n\tmockRecorder := mockObj.EXPECT()\n\n\tmockRecorder.Reset()\n\n\tmockObj.Reset()\n}\n",
    "amount_of_generated_test_cases": 10,
    "single_test_run_command": "go test -v config/dynamic_object_mock_test.go"
}