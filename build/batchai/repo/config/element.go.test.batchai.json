{
    "path": "config/element.go",
    "model_usage_metrics": {
        "Duration": 28176115779,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "config/element_test.go",
    "existing_test_code": "",
    "original_code": "package config\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/gookit/goutil/strutil\"\n\t\"github.com/qiangyt/jog/util\"\n)\n\n// ElementT ...\ntype ElementT struct {\n\tColor       util.Color\n\tPrint       bool\n\tPrintFormat string `yaml:\"print-format\"`\n}\n\n// Element ...\ntype Element = *ElementT\n\n// UnmarshalYAML ...\nfunc (i Element) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\treturn UnmarshalYAML(i, unmarshal)\n}\n\n// MarshalYAML ...\nfunc (i Element) MarshalYAML() (interface{}, error) {\n\treturn MarshalYAML(i)\n}\n\n// Init ...\nfunc (i Element) Init(cfg Configuration) {\n\n}\n\n// FromMap ...\nfunc (i Element) FromMap(m map[string]interface{}) error {\n\tcolorV := util.ExtractFromMap(m, \"color\")\n\tif colorV != nil {\n\t\tif err := util.UnmashalYAMLAgain(colorV, \u0026i.Color); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tprintV := util.ExtractFromMap(m, \"print\")\n\tif printV != nil {\n\t\ti.Print = util.ToBool(printV)\n\t}\n\n\tprintFormatV := util.ExtractFromMap(m, \"print-format\")\n\tif printFormatV != nil {\n\t\tprintFormatT := strutil.MustString(printFormatV)\n\t\tif validPrintFormat(printFormatT) {\n\t\t\ti.PrintFormat = printFormatT\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"invalid print-format: %s\", printFormatT)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n/* validPrintFormat check print-format if it's valid and meaningful\n * only verbs `s` and `v` are valid at the moment\n * `%5.s` is valid, but not meaningful, because the output will be empty, will not be accepted\n * `%.5s` is valid, but not very meaningful, but will be accepted\n */\nfunc validPrintFormat(printFormat string) bool {\n\tvar re = regexp.MustCompile(`%(-{0,1}\\d{1,}){0,1}(\\.\\d{1,}){0,1}([sv])`)\n\treturn re.MatchString(printFormat)\n}\n\n// ToMap ...\nfunc (i Element) ToMap() map[string]interface{} {\n\tr := make(map[string]interface{})\n\tr[\"color\"] = i.Color.String()\n\tr[\"print\"] = i.Print\n\tr[\"print-format\"] = i.PrintFormat\n\treturn r\n}\n\n// Reset ...\nfunc (i Element) Reset() {\n\ti.Color = \u0026util.ColorT{}\n\ti.Color.Set(\"OpReset\")\n\n\ti.Print = true\n\n\ti.PrintFormat = \"%s\"\n}\n\n// GetColor ...\nfunc (i Element) GetColor(value string) util.Color {\n\treturn i.Color\n}\n\n// IsEnabled ...\nfunc (i Element) IsEnabled() bool {\n\treturn i.Print\n}\n\n// PrintTo ...\nfunc (i Element) PrintTo(color util.Color, builder *strings.Builder, a string) {\n\ta = ShortenValue(a, i.PrintFormat)\n\tif color == nil {\n\t\tbuilder.WriteString(fmt.Sprintf(i.PrintFormat, a))\n\t} else {\n\t\tbuilder.WriteString(color.Sprintf(i.PrintFormat, a))\n\t}\n}\n\n// ShortenValue shortens the value to maxWidth -3 chars if necessary, shortened values will be postfixed by three dots\nfunc ShortenValue(inValue string, printFormat string) string {\n\tidx := strings.Index(printFormat, \".\")\n\tif idx \u003e= 0 {\n\t\twidth, err := strconv.Atoi(printFormat[1:idx])\n\t\tif err == nil \u0026\u0026 len([]rune(inValue)) \u003e abs(width) \u0026\u0026 abs(width) \u003e 3 {\n\t\t\treturn fmt.Sprint(inValue[:abs(width)-3], \"...\")\n\t\t}\n\t}\n\treturn inValue\n}\n\n// abs function that works for int, Math.Abs only accepts float64\nfunc abs(value int) int {\n\tif value \u003c 0 {\n\t\tvalue = value * -1\n\t}\n\treturn value\n}\n",
    "test_code": "package config\n\nimport (\n\t\"testing\"\n)\n\nfunc TestElementT_UnmarshalYAML(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   map[string]interface{}\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Happy path\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"color\":       \"#FF0000\",\n\t\t\t\t\"print\":       true,\n\t\t\t\t\"print-format\": \"%s\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative path - invalid color\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"color\":       \"invalid_color\",\n\t\t\t\t\"print\":       true,\n\t\t\t\t\"print-format\": \"%s\",\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative path - invalid print format\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"color\":       \"#FF0000\",\n\t\t\t\t\"print\":       true,\n\t\t\t\t\"print-format\": \"%5.s\",\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Corner case - empty input\",\n\t\t\tinput: map[string]interface{}{},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative path - missing print format\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"color\": \"#FF0000\",\n\t\t\t\t\"print\": true,\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative path - invalid boolean value for print\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"color\":       \"#FF0000\",\n\t\t\t\t\"print\":       \"invalid_bool\",\n\t\t\t\t\"print-format\": \"%s\",\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Negative path - invalid color format\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"color\":       \"#ZZZZZ\",\n\t\t\t\t\"print\":       true,\n\t\t\t\t\"print-format\": \"%s\",\n\t\t\t},\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Happy path - with default values\",\n\t\t\tinput: map[string]interface{}{\n\t\t\t\t\"color\": \"#FF0000\",\n\t\t\t},\n\t\t\twantErr: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ti := \u0026ElementT{}\n\t\t\terr := i.FromMap(tt.input)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"FromMap() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestElementT_ToMap(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   Element\n\t\twant    map[string]interface{}\n\t}{\n\t\t{\n\t\t\tname: \"Happy path\",\n\t\t\tinput: \u0026ElementT{\n\t\t\t\tColor:       util.Color{Value: \"#FF0000\"},\n\t\t\t\tPrint:       true,\n\t\t\t\tPrintFormat: \"%s\",\n\t\t\t},\n\t\t\twant: map[string]interface{}{\n\t\t\t\t\"color\":       \"#FF0000\",\n\t\t\t\t\"print\":       true,\n\t\t\t\t\"print-format\": \"%s\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Corner case - default values\",\n\t\t\tinput: \u0026ElementT{},\n\t\t\twant: map[string]interface{}{\n\t\t\t\t\"color\":       \"#FFFFFF\",\n\t\t\t\t\"print\":       true,\n\t\t\t\t\"print-format\": \"%s\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.ToMap()\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"ToMap() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestElementT_Reset(t *testing.T) {\n\ttests := []struct {\n\t\tname string\n\t\twant Element\n\t}{\n\t\t{\n\t\t\tname: \"Happy path\",\n\t\t\twant: \u0026ElementT{\n\t\t\t\tColor:       util.Color{Value: \"#FFFFFF\"},\n\t\t\t\tPrint:       true,\n\t\t\t\tPrintFormat: \"%s\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ti := \u0026ElementT{}\n\t\t\ti.Reset()\n\t\t\tif !reflect.DeepEqual(i, tt.want) {\n\t\t\t\tt.Errorf(\"Reset() = %v, want %v\", i, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestElementT_PrintFormat(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   Element\n\t\twant    string\n\t}{\n\t\t{\n\t\t\tname: \"Happy path\",\n\t\t\tinput: \u0026ElementT{\n\t\t\t\tPrintFormat: \"%s\",\n\t\t\t},\n\t\t\twant: \"%s\",\n\t\t},\n\t\t{\n\t\t\tname: \"Corner case - default value\",\n\t\t\tinput: \u0026ElementT{},\n\t\t\twant: \"%s\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.PrintFormat()\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"PrintFormat() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestElementT_Color(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   Element\n\t\twant    util.Color\n\t}{\n\t\t{\n\t\t\tname: \"Happy path\",\n\t\t\tinput: \u0026ElementT{\n\t\t\t\tColor: util.Color{Value: \"#FF0000\"},\n\t\t\t},\n\t\t\twant: util.Color{Value: \"#FF0000\"},\n\t\t},\n\t\t{\n\t\t\tname: \"Corner case - default value\",\n\t\t\tinput: \u0026ElementT{},\n\t\t\twant: util.Color{Value: \"#FFFFFF\"},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Color()\n\t\t\tif !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"Color() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestElementT_Print(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\tinput   Element\n\t\twant    bool\n\t}{\n\t\t{\n\t\t\tname: \"Happy path\",\n\t\t\tinput: \u0026ElementT{\n\t\t\t\tPrint: true,\n\t\t\t},\n\t\t\twant: true,\n\t\t},\n\t\t{\n\t\t\tname: \"Corner case - default value\",\n\t\t\tinput: \u0026ElementT{},\n\t\t\twant: false,\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot := tt.input.Print()\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Print() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "amount_of_generated_test_cases": 8,
    "single_test_run_command": "go test config/element_test.go"
}