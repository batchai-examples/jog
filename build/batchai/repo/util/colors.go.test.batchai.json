{
    "path": "util/colors.go",
    "model_usage_metrics": {
        "Duration": 19576433783,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "util/colors_test.go",
    "existing_test_code": "",
    "original_code": "package util\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/gookit/color\"\n\t\"github.com/gookit/goutil/strutil\"\n\t\"github.com/pkg/errors\"\n\t\"gopkg.in/yaml.v2\"\n)\n\n// Colors ...\nvar Colors = map[string]color.Color{\n\t\"FgBlack\":         color.FgBlack,\n\t\"FgRed\":           color.FgRed,\n\t\"FgGreen\":         color.FgGreen,\n\t\"FgYellow\":        color.FgYellow,\n\t\"FgBlue\":          color.FgBlue,\n\t\"FgMagenta\":       color.FgMagenta,\n\t\"FgCyan\":          color.FgCyan,\n\t\"FgWhite\":         color.FgWhite,\n\t\"FgDefault\":       color.FgDefault,\n\t\"FgDarkGray\":      color.FgDarkGray,\n\t\"FgLightRed\":      color.FgLightRed,\n\t\"FgLightGreen\":    color.FgLightGreen,\n\t\"FgLightYellow\":   color.FgLightYellow,\n\t\"FgLightBlue\":     color.FgLightBlue,\n\t\"FgLightMagenta\":  color.FgLightMagenta,\n\t\"FgLightCyan\":     color.FgLightCyan,\n\t\"FgLightWhite\":    color.FgLightWhite,\n\t\"FgGray\":          color.FgGray,\n\t\"BgBlack\":         color.BgBlack,\n\t\"BgRed\":           color.BgRed,\n\t\"BgGreen\":         color.BgGreen,\n\t\"BgYellow\":        color.BgYellow,\n\t\"BgBlue\":          color.BgBlue,\n\t\"BgMagenta\":       color.BgMagenta,\n\t\"BgCyan\":          color.BgCyan,\n\t\"BgWhite\":         color.BgWhite,\n\t\"BgDefault\":       color.BgDefault,\n\t\"BgDarkGray\":      color.BgDarkGray,\n\t\"BgLightRed\":      color.BgLightRed,\n\t\"BgLightGreen\":    color.BgLightGreen,\n\t\"BgLightYellow\":   color.BgLightYellow,\n\t\"BgLightBlue\":     color.BgLightBlue,\n\t\"BgLightMagenta\":  color.BgLightMagenta,\n\t\"BgLightCyan\":     color.BgLightCyan,\n\t\"BgLightWhite\":    color.BgLightWhite,\n\t\"BgGray\":          color.BgGray,\n\t\"OpReset\":         color.OpReset,\n\t\"OpBold\":          color.OpBold,\n\t\"OpFuzzy\":         color.OpFuzzy,\n\t\"OpItalic\":        color.OpItalic,\n\t\"OpUnderscore\":    color.OpUnderscore,\n\t\"OpBlink\":         color.OpBlink,\n\t\"OpFastBlink\":     color.OpFastBlink,\n\t\"OpReverse\":       color.OpReverse,\n\t\"OpConcealed\":     color.OpConcealed,\n\t\"OpStrikethrough\": color.OpStrikethrough,\n\t\"Red\":             color.Red,\n\t\"Cyan\":            color.Cyan,\n\t\"Gray\":            color.Gray,\n\t\"Blue\":            color.Blue,\n\t\"Black\":           color.Black,\n\t\"Green\":           color.Green,\n\t\"White\":           color.White,\n\t\"Yellow\":          color.Yellow,\n\t\"Magenta\":         color.Magenta,\n\t\"Bold\":            color.Bold,\n\t\"Normal\":          color.Normal,\n\t\"LightRed\":        color.LightRed,\n\t\"LightCyan\":       color.LightCyan,\n\t\"LightBlue\":       color.LightBlue,\n\t\"LightGreen\":      color.LightGreen,\n\t\"LightWhite\":      color.LightWhite,\n\t\"LightYellow\":     color.LightYellow,\n\t\"LightMagenta\":    color.LightMagenta,\n}\n\n// ColorsFromLabel ...\nfunc ColorsFromLabel(label string) (color.Style, error) {\n\tcolorNais := strutil.Split(label, \",\")\n\tr := make([]color.Color, 0, len(colorNais))\n\n\tfor _, colorNai := range colorNais {\n\t\tc, has := Colors[colorNai]\n\t\tif !has {\n\t\t\treturn nil, fmt.Errorf(\"unknown color name '%s' in '%s'. allowed: %v\", colorNai, label, Colors)\n\t\t}\n\t\tr = append(r, c)\n\t}\n\n\treturn color.New(r...), nil\n}\n\n// ColorT ...\ntype ColorT struct {\n\tyaml.Unmarshaler\n\tyaml.Marshaler\n\n\tlabel string\n\tstyle color.Style\n}\n\n// Color ...\ntype Color = *ColorT\n\n// Reset ...\nfunc (i Color) Reset() {\n\ti.label = \"FgDefault\"\n\ti.style, _ = ColorsFromLabel(i.label)\n}\n\n// Set ...\nfunc (i Color) Set(label string) {\n\tstyle, err := ColorsFromLabel(label)\n\tif err != nil {\n\t\tpanic(errors.Wrap(err, \"\"))\n\t}\n\n\ti.label = label\n\ti.style = style\n}\n\nfunc (i Color) String() string {\n\treturn i.label\n}\n\n// UnmarshalYAML ...\nfunc (i Color) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar err error\n\n\tif err = unmarshal(\u0026i.label); err != nil {\n\t\ti.Reset()\n\t\treturn err\n\t}\n\n\ti.style, err = ColorsFromLabel(i.label)\n\tif err != nil {\n\t\ti.Reset()\n\t}\n\treturn err\n}\n\n// MarshalYAML ...\nfunc (i Color) MarshalYAML() (interface{}, error) {\n\treturn i.String(), nil\n}\n\n// Sprint is alias of the 'Render'\nfunc (i Color) Sprint(a interface{}) string {\n\treturn i.style.Sprint(a)\n}\n\n// Sprintf is alias of the 'Render'\nfunc (i Color) Sprintf(format string, a ...interface{}) string {\n\treturn i.style.Sprintf(format, a...)\n}\n",
    "test_code": "package util\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestColorsFromLabel_HappyPath(t *testing.T) {\n\t// Given a valid label with multiple color names separated by commas\n\tlabel := \"FgRed,BgGreen,OpBold\"\n\n\t// When calling ColorsFromLabel with the given label\n\tstyle, err := ColorsFromLabel(label)\n\n\t// Then no error should be returned and the style should contain the expected colors and options\n\tassert.NoError(t, err)\n\tassert.Equal(t, color.FgRed|color.BgGreen|color.OpBold, style)\n}\n\nfunc TestColorsFromLabel_InvalidColorName(t *testing.T) {\n\t// Given a label with an invalid color name\n\tlabel := \"FgRed,UnknownColor,BgGreen\"\n\n\t// When calling ColorsFromLabel with the given label\n\t_, err := ColorsFromLabel(label)\n\n\t// Then an error should be returned indicating that the unknown color name is not allowed\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"unknown color name 'UnknownColor' in\")\n}\n\nfunc TestColorsFromLabel_EmptyLabel(t *testing.T) {\n\t// Given an empty label\n\tlabel := \"\"\n\n\t// When calling ColorsFromLabel with the given label\n\tstyle, err := ColorsFromLabel(label)\n\n\t// Then no error should be returned and the style should be reset to default\n\tassert.NoError(t, err)\n\tassert.Equal(t, color.FgDefault, style)\n}\n\nfunc TestColorsFromLabel_SingleColor(t *testing.T) {\n\t// Given a label with a single valid color name\n\tlabel := \"FgBlue\"\n\n\t// When calling ColorsFromLabel with the given label\n\tstyle, err := ColorsFromLabel(label)\n\n\t// Then no error should be returned and the style should contain only the specified color\n\tassert.NoError(t, err)\n\tassert.Equal(t, color.FgBlue, style)\n}\n\nfunc TestColorsFromLabel_MultipleOptions(t *testing.T) {\n\t// Given a label with multiple options separated by commas\n\tlabel := \"OpBold,OpItalic\"\n\n\t// When calling ColorsFromLabel with the given label\n\tstyle, err := ColorsFromLabel(label)\n\n\t// Then no error should be returned and the style should contain only the specified options\n\tassert.NoError(t, err)\n\tassert.Equal(t, color.OpBold|color.OpItalic, style)\n}\n\nfunc TestColorsFromLabel_MixedColorAndOption(t *testing.T) {\n\t// Given a label with both valid color names and options separated by commas\n\tlabel := \"FgRed,OpBold\"\n\n\t// When calling ColorsFromLabel with the given label\n\tstyle, err := ColorsFromLabel(label)\n\n\t// Then no error should be returned and the style should contain the specified color and option\n\tassert.NoError(t, err)\n\tassert.Equal(t, color.FgRed|color.OpBold, style)\n}\n\nfunc TestColorsFromLabel_LeadingTrailingSpaces(t *testing.T) {\n\t// Given a label with leading and trailing spaces around valid color names\n\tlabel := \"  FgGreen,BgBlue  \"\n\n\t// When calling ColorsFromLabel with the given label\n\tstyle, err := ColorsFromLabel(label)\n\n\t// Then no error should be returned and the style should contain only the specified colors\n\tassert.NoError(t, err)\n\tassert.Equal(t, color.FgGreen|color.BgBlue, style)\n}\n\nfunc TestColorsFromLabel_CommaOnly(t *testing.T) {\n\t// Given a label with only commas\n\tlabel := \",\"\n\n\t// When calling ColorsFromLabel with the given label\n\tstyle, err := ColorsFromLabel(label)\n\n\t// Then no error should be returned and the style should be reset to default\n\tassert.NoError(t, err)\n\tassert.Equal(t, color.FgDefault, style)\n}\n\nfunc TestColorsFromLabel_SingleInvalidColorName(t *testing.T) {\n\t// Given a label with a single invalid color name\n\tlabel := \"UnknownColor\"\n\n\t// When calling ColorsFromLabel with the given label\n\t_, err := ColorsFromLabel(label)\n\n\t// Then an error should be returned indicating that the unknown color name is not allowed\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"unknown color name 'UnknownColor' in\")\n}\n\nfunc TestColorsFromLabel_MultipleInvalidColorNames(t *testing.T) {\n\t// Given a label with multiple invalid color names separated by commas\n\tlabel := \"UnknownColor1,UnknownColor2\"\n\n\t// When calling ColorsFromLabel with the given label\n\t_, err := ColorsFromLabel(label)\n\n\t// Then an error should be returned indicating that the unknown color names are not allowed\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), \"unknown color name 'UnknownColor1' in\")\n\tassert.Contains(t, err.Error(), \"unknown color name 'UnknownColor2' in\")\n}\n",
    "amount_of_generated_test_cases": 10,
    "single_test_run_command": "go test -v util/colors_test.go"
}