{
    "path": "util/multi_string.go",
    "model_usage_metrics": {
        "Duration": 32739813507,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "util/multi_string_test.go",
    "existing_test_code": "",
    "original_code": "package util\n\nimport (\n\t\"strings\"\n\n\t\"github.com/gookit/goutil/strutil\"\n\t\"gopkg.in/yaml.v2\"\n)\n\n// TODO: is it duplicated with StringSet?\n// MultiStringT ...\ntype MultiStringT struct {\n\tyaml.Unmarshaler\n\tyaml.Marshaler\n\n\tText             string\n\tValues           map[string]bool\n\tLowercasedValues map[string]bool\n}\n\n// MultiString ...\ntype MultiString = *MultiStringT\n\n// Set ...\nfunc (i MultiString) Set(valuesText string) {\n\ti.Text = valuesText\n\n\ti.Values = make(map[string]bool)\n\ti.LowercasedValues = make(map[string]bool)\n\n\tfor _, v := range strutil.Split(valuesText, \",\") {\n\t\tv = strings.Trim(v, \"\\t\\r\\n \")\n\t\ti.Values[v] = true\n\t\ti.LowercasedValues[strings.ToLower(v)] = true\n\t}\n}\n\n// Reset ...\nfunc (i MultiString) Reset() {\n\ti.Set(\"\")\n}\n\n// Contains ...\nfunc (i MultiString) Contains(v string, caseSensitive bool) bool {\n\tr := i.Values[v]\n\tif r {\n\t\treturn true\n\t}\n\tif !caseSensitive {\n\t\treturn i.LowercasedValues[v]\n\t}\n\treturn false\n}\n\nfunc (i MultiString) String() string {\n\treturn i.Text\n}\n\n// UnmarshalYAML ...\nfunc (i MultiString) UnmarshalYAML(unmarshal func(interface{}) error) error {\n\tvar valuesText string\n\terr := unmarshal(\u0026valuesText)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ti.Set(valuesText)\n\n\treturn nil\n}\n\n// MarshalYAML ...\nfunc (i MultiString) MarshalYAML() (interface{}, error) {\n\treturn i.String(), nil\n}\n",
    "test_code": "package util\n\nimport (\n\t\"testing\"\n)\n\nfunc TestMultiString_Set(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected map[string]bool\n\t}{\n\t\t{\n\t\t\tname:     \"Happy path\",\n\t\t\tinput:    \"apple,banana,cherry\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tname:     \"Single value\",\n\t\t\tinput:    \"apple\",\n\t\t\texpected: map[string]bool{\"apple\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Whitespace around values\",\n\t\t\tinput:    \"  apple, banana , cherry \",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Duplicate values\",\n\t\t\tinput:    \"apple,apple,banana\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Mixed case values\",\n\t\t\tinput:    \"Apple,Banana,cherry\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Special characters in values\",\n\t\t\tinput:    \"apple!@#banana$%^cherry\u0026*()\",\n\t\t\texpected: map[string]bool{\"apple!@#banana$%^cherry\u0026*()\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative case - non-string input\",\n\t\t\tinput:    \"123,456\",\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative case - empty values\",\n\t\t\tinput:    \",,,\",\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative case - only whitespace\",\n\t\t\tinput:    \"   \",\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ti := \u0026MultiStringT{}\n\t\t\ti.Set(tc.input)\n\n\t\t\tif !reflect.DeepEqual(i.Values, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, i.Values)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMultiString_Contains(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    MultiString\n\t\tvalue    string\n\t\tcaseSensitive bool\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"Happy path - case sensitive\",\n\t\t\tinput:    \u0026MultiStringT{Values: map[string]bool{\"apple\": true, \"banana\": true}},\n\t\t\tvalue:    \"apple\",\n\t\t\tcaseSensitive: true,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Happy path - case insensitive\",\n\t\t\tinput:    \u0026MultiStringT{LowercasedValues: map[string]bool{\"apple\": true, \"banana\": true}},\n\t\t\tvalue:    \"Apple\",\n\t\t\tcaseSensitive: false,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative case - value not found\",\n\t\t\tinput:    \u0026MultiStringT{Values: map[string]bool{\"apple\": true, \"banana\": true}},\n\t\t\tvalue:    \"cherry\",\n\t\t\tcaseSensitive: true,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative case - empty MultiString\",\n\t\t\tinput:    \u0026MultiStringT{},\n\t\t\tvalue:    \"apple\",\n\t\t\tcaseSensitive: true,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative case - non-string input\",\n\t\t\tinput:    \u0026MultiStringT{Values: map[string]bool{\"123\": true}},\n\t\t\tvalue:    \"456\",\n\t\t\tcaseSensitive: true,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult := tc.input.Contains(tc.value, tc.caseSensitive)\n\n\t\t\tif result != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMultiString_Reset(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    MultiString\n\t\texpected map[string]bool\n\t}{\n\t\t{\n\t\t\tname:     \"Happy path\",\n\t\t\tinput:    \u0026MultiStringT{Values: map[string]bool{\"apple\": true, \"banana\": true}},\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tname:     \"Negative case - empty MultiString\",\n\t\t\tinput:    \u0026MultiStringT{},\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ttc.input.Reset()\n\n\t\t\tif !reflect.DeepEqual(tc.input.Values, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, tc.input.Values)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMultiString_UnmarshalYAML(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    string\n\t\texpected map[string]bool\n\t}{\n\t\t{\n\t\t\tname:     \"Happy path\",\n\t\t\tinput:    \"apple,banana,cherry\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty string\",\n\t\t\tinput:    \"\",\n\t\t\texpected: map[string]bool{},\n\t\t},\n\t\t{\n\t\t\tname:     \"Single value\",\n\t\t\tinput:    \"apple\",\n\t\t\texpected: map[string]bool{\"apple\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Whitespace around values\",\n\t\t\tinput:    \"  apple, banana , cherry \",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Duplicate values\",\n\t\t\tinput:    \"apple,apple,banana\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Mixed case values\",\n\t\t\tinput:    \"Apple,Banana,cherry\",\n\t\t\texpected: map[string]bool{\"apple\": true, \"banana\": true, \"cherry\": true},\n\t\t},\n\t\t{\n\t\t\tname:     \"Special characters in input\",\n\t\t\tinput:    \"apple!@#banana$%^cherry\u0026*()\",\n\t\t\texpected: map[string]bool{\"apple!@#\": true, \"banana$%^\": true, \"cherry\u0026*()\": true},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\ti := \u0026MultiStringT{}\n\t\t\terr := yaml.Unmarshal([]byte(tc.input), i)\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(i.Values, tc.expected) {\n\t\t\t\tt.Errorf(\"Expected %v, got %v\", tc.expected, i.Values)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestMultiString_MarshalYAML(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tinput    MultiString\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tname:     \"Happy path\",\n\t\t\tinput:    \u0026MultiStringT{Values: map[string]bool{\"apple\": true, \"banana\": true}},\n\t\t\texpected: \"apple,banana\",\n\t\t},\n\t\t{\n\t\t\tname:     \"Empty MultiString\",\n\t\t\tinput:    \u0026MultiStringT{},\n\t\t\texpected: \"\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tresult, err := yaml.Marshal(tc.input)\n\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Expected no error, got %v\", err)\n\t\t\t}\n\n\t\t\tif string(result) != tc.expected {\n\t\t\t\tt.Errorf(\"Expected %s, got %s\", tc.expected, result)\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "amount_of_generated_test_cases": 10,
    "single_test_run_command": "go test -v util/multi_string_test.go"
}