{
    "path": "util/misc_test.go",
    "model_usage_metrics": {
        "Duration": 4610317066,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "util/misc_test.go",
    "existing_test_code": "",
    "original_code": "package util\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/agiledragon/gomonkey/v2\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/require\"\n\t\"gopkg.in/yaml.v2\"\n)\n\nfunc Test_ExeDirectory_happy(t *testing.T) {\n\tassert := require.New(t)\n\n\tassert.Contains(ExeDirectory(), \"go-build\")\n\n\tpatches := gomonkey.ApplyFunc(filepath.Abs, func(_ string) (string, error) {\n\t\treturn \"\", errors.New(\"\")\n\t})\n\tdefer patches.Reset()\n\n\tassert.Panics(func() { exeDirectory(\"\") })\n}\n\nfunc Test_FileStat(t *testing.T) {\n\tassert := require.New(t)\n\n\tfi := FileStat(\"/home\", true)\n\tassert.NotNil(fi)\n\tassert.True(fi.IsDir())\n\tassert.Equal(\"home\", fi.Name())\n\n\tassert.Nil(FileStat(\"/not_existed\", false))\n\n\tassert.Panics(func() {\n\t\tFileStat(\"/not_exists\", true)\n\t})\n\n\tassert.Panics(func() {\n\t\tFileStat(\"/root/.ssh\", false)\n\t})\n}\n\nfunc Test_FileExists(t *testing.T) {\n\tassert := require.New(t)\n\n\tassert.False(FileExists(\"/not_exists.txt\"))\n\tassert.True(FileExists(\"/etc/hosts\"))\n\n\tassert.Panics(func() {\n\t\tFileExists(\"/home\")\n\t})\n}\n\nfunc Test_DirExists(t *testing.T) {\n\tassert := require.New(t)\n\n\tassert.False(DirExists(\"/not_exists\"))\n\tassert.True(DirExists(\"/home\"))\n\n\tassert.Panics(func() {\n\t\tDirExists(\"/etc/hosts\")\n\t})\n}\n\nfunc Test_RemoveFile(t *testing.T) {\n\tassert := require.New(t)\n\n\tf, _ := ioutil.TempFile(\"\", \"jog_*.txt\")\n\tpath := f.Name()\n\tf.Close()\n\n\tRemoveFile(path)\n\n\tWriteFileIfNotFound(path, []byte(\"abc\"))\n\tassert.True(FileExists(path))\n\tRemoveFile(path)\n\tassert.False(FileExists(path))\n\n\tassert.True(FileExists(\"/etc/hosts\"))\n\tassert.Panics(func() {\n\t\tRemoveFile(\"/etc/hosts\")\n\t})\n\tassert.True(FileExists(\"/etc/hosts\"))\n}\n\nfunc Test_RemoveDir(t *testing.T) {\n\tassert := require.New(t)\n\n\tpath, _ := ioutil.TempDir(\"\", \"jog_*\")\n\tassert.True(DirExists(path))\n\tRemoveDir(path)\n\tassert.False(DirExists(path))\n\n\tassert.True(DirExists(\"/root\"))\n\tassert.Panics(func() {\n\t\tRemoveDir(\"/root\")\n\t})\n\tassert.True(DirExists(\"/root\"))\n\n\tassert.True(DirExists(\"/\"))\n\tassert.Panics(func() {\n\t\tRemoveDir(\"/\")\n\t})\n\tassert.True(DirExists(\"/\"))\n}\n\nfunc Test_ReadFile(t *testing.T) {\n\tassert := require.New(t)\n\n\tf, _ := ioutil.TempFile(\"\", \"jog_*.txt\")\n\tpath := f.Name()\n\tf.Close()\n\n\tRemoveFile(path)\n\tassert.Panics(func() {\n\t\tReadFile(path)\n\t})\n\n\tWriteFileIfNotFound(path, []byte(\"abc\"))\n\tassert.True(FileExists(path))\n\n\tcontent := ReadFile(path)\n\tassert.Equal(\"abc\", string(content))\n}\n\nfunc Test_WriteFileIfNotFound(t *testing.T) {\n\tassert := require.New(t)\n\n\tf, _ := ioutil.TempFile(\"\", \"jog_*.txt\")\n\tpath := f.Name()\n\tf.Close()\n\n\tRemoveFile(path)\n\tWriteFileIfNotFound(path, []byte(\"old\"))\n\tcontent := ReadFile(path)\n\tassert.Equal(\"old\", string(content))\n\n\tWriteFileIfNotFound(path, []byte(\"new\"))\n\tcontent = ReadFile(path)\n\tassert.Equal(\"old\", string(content))\n}\n\nfunc Test_ReplaceFile(t *testing.T) {\n\tassert := require.New(t)\n\n\tf, _ := ioutil.TempFile(\"\", \"jog_*.txt\")\n\tpath := f.Name()\n\tf.Close()\n\n\tRemoveFile(path)\n\tReplaceFile(path, []byte(\"1\"))\n\tcontent := ReadFile(path)\n\tassert.Equal(\"1\", string(content))\n\n\tReplaceFile(path, []byte(\"2\"))\n\tcontent = ReadFile(path)\n\tassert.Equal(\"2\", string(content))\n\n\tassert.Panics(func() {\n\t\tReplaceFile(\"/etc/hosts\", []byte(\"bad\"))\n\t})\n}\n\nfunc Test_ExpandHomePath(t *testing.T) {\n\tassert := require.New(t)\n\n\thome := os.Getenv(\"HOME\")\n\tassert.Equal(home+\"/jog.txt\", ExpandHomePath(\"~/jog.txt\"))\n\n\tassert.Panics(func() {\n\t\tReadFile(ExpandHomePath(\"~jog.txt\"))\n\t})\n}\n\nfunc Test_UnmashalYAMLAgain(t *testing.T) {\n\tassert := require.New(t)\n\n\ttype Temp struct {\n\t\tK string\n\t}\n\tin := Temp{K: \"v\"}\n\tout := Temp{K: \"\"}\n\tassert.NoError(UnmashalYAMLAgain(in, \u0026out))\n\tassert.Equal(in, out)\n\n\tpatches := gomonkey.ApplyFunc(yaml.Marshal, func(_ interface{}) ([]byte, error) {\n\t\treturn nil, errors.New(\"\")\n\t})\n\tdefer patches.Reset()\n\tassert.Error(UnmashalYAMLAgain(in, \u0026out))\n}\n\nfunc Test_ToBool(t *testing.T) {\n\tassert := require.New(t)\n\n\tassert.True(ToBool(true))\n\tassert.False(ToBool(false))\n\n\tassert.True(ToBool(\"true\"))\n\tassert.False(ToBool(\"false\"))\n\tassert.True(ToBool(\"True\"))\n\tassert.False(ToBool(\"False\"))\n\tassert.True(ToBool(\"TRUE\"))\n\tassert.False(ToBool(\"FALSE\"))\n\n\tassert.True(ToBool(\"yes\"))\n\tassert.False(ToBool(\"no\"))\n\tassert.True(ToBool(\"Yes\"))\n\tassert.False(ToBool(\"No\"))\n\tassert.True(ToBool(\"YES\"))\n\tassert.False(ToBool(\"NO\"))\n\n\tassert.True(ToBool(1))\n\tassert.False(ToBool(0))\n\tassert.True(ToBool(\"1\"))\n\tassert.False(ToBool(\"0\"))\n\n\tassert.True(ToBool(\"on\"))\n\tassert.False(ToBool(\"off\"))\n\tassert.True(ToBool(\"On\"))\n\tassert.False(ToBool(\"Off\"))\n\tassert.True(ToBool(\"ON\"))\n\tassert.False(ToBool(\"OFF\"))\n\n\tassert.False(ToBool(nil))\n\tassert.False(ToBool(map[string]int{}))\n}\n\nfunc Test_ExtractFromMap(t *testing.T) {\n\tassert := require.New(t)\n\n\tm := map[string]interface{}{\"k\": \"v\"}\n\n\tassert.Equal(\"v\", ExtractFromMap(m, \"k\"))\n\n\t_, has := m[\"k\"]\n\tassert.False(has, \"should be removed\")\n\n\tassert.Nil(ExtractFromMap(m, \"k\"))\n}\n\nfunc Test_ExtractStringSliceFromMap(t *testing.T) {\n\tassert := require.New(t)\n\n\tm := map[string]interface{}{\n\t\t\"k\": []string{\"v0\", \"v1\"},\n\t\t\"p\": \"not slice\",\n\t\t\"z\": nil,\n\t}\n\n\tv, err := ExtractStringSliceFromMap(m, \"k\")\n\tassert.NoError(err)\n\tassert.Equal(2, len(v))\n\tassert.Equal(\"v0\", v[0])\n\tassert.Equal(\"v1\", v[1])\n\t_, has := m[\"k\"]\n\tassert.False(has, \"should be removed\")\n\n\tv, err = ExtractStringSliceFromMap(m, \"k\")\n\tassert.NoError(err)\n\tassert.Equal(0, len(v))\n\n\tv, err = ExtractStringSliceFromMap(m, \"p\")\n\tassert.Error(err)\n\tassert.Nil(v)\n\t_, has = m[\"p\"]\n\tassert.True(has, \"should be still there\")\n\n\tv, err = ExtractStringSliceFromMap(m, \"z\")\n\tassert.NoError(err)\n\tassert.Equal(0, len(v))\n}\n\nfunc Test_MkdirAll(t *testing.T) {\n\tassert := require.New(t)\n\n\tassert.Panics(func() {\n\t\tMkdirAll(\"/root/test\")\n\t})\n\n\tpath := os.TempDir() + \"/jog_test/1/2/3/4/5/6\"\n\tassert.NoDirExists(path)\n\n\tMkdirAll(path)\n\tdefer RemoveDir(path)\n\tassert.DirExists(path)\n}\n\nfunc Test_MustStringSlice(t *testing.T) {\n\tassert := require.New(t)\n\n\tinput := []string{\"a\"}\n\ts, err := MustStringSlice(input)\n\tassert.NoError(err)\n\tassert.Equal(input, s)\n\n\ts, err = MustStringSlice([]interface{}{\"A\"})\n\tassert.NoError(err)\n\tassert.Equal(1, len(s))\n\tassert.Equal(\"A\", s[0])\n\n\tassert.Panics(func() { MustStringSlice([]interface{}{789}) })\n\n\ts, err = MustStringSlice([]int{})\n\tassert.Error(err)\n\tassert.Nil(s)\n}\n",
    "test_code": "package util\n\nimport (\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/agiledragon/gomonkey\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc Test_ExtractStringSliceFromMap_Error(t *testing.T) {\n\tassert := assert.New(t)\n\tm := map[string]interface{}{\n\t\t\"k\": \"not slice\",\n\t}\n\n\tv, err := ExtractStringSliceFromMap(m, \"k\")\n\tassert.Error(err)\n\tassert.Nil(v)\n\t_, has := m[\"k\"]\n\tassert.True(has, \"should be still there\")\n}\n",
    "amount_of_generated_test_cases": 2,
    "single_test_run_command": "go test -v util"
}