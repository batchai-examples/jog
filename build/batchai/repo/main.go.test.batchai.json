{
    "path": "main.go",
    "model_usage_metrics": {
        "Duration": 13621462252,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "main_test.go",
    "existing_test_code": "",
    "original_code": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/gookit/color\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/qiangyt/jog/config\"\n\t\"github.com/qiangyt/jog/jsonpath\"\n\t\"github.com/qiangyt/jog/util\"\n\t\"gopkg.in/yaml.v2\"\n)\n\n//go:generate go run script/include_static.go\n\n// ParseConfigExpression ...\nfunc ParseConfigExpression(expr string) (string, string, error) {\n\tarr := strings.Split(expr, \"=\")\n\tif len(arr) != 2 {\n\t\treturn \"\", \"\", fmt.Errorf(\"invalid config item expression: \u003c%s\u003e\", expr)\n\t}\n\treturn arr[0], arr[1], nil\n}\n\n// ReadConfig ...\nfunc ReadConfig(configFilePath string) config.Configuration {\n\tif len(configFilePath) == 0 {\n\t\treturn config.WithDefaultYamlFile()\n\t}\n\treturn config.WithYamlFile(configFilePath)\n}\n\n// PrintConfigItem ...\nfunc PrintConfigItem(m map[string]interface{}, configItemPath string) {\n\titem, err := jsonpath.Get(m, configItemPath)\n\tif err != nil {\n\t\tpanic(errors.Wrap(err, \"\"))\n\t}\n\tout, err := yaml.Marshal(item)\n\tif err != nil {\n\t\tpanic(errors.Wrap(err, \"\"))\n\t}\n\tfmt.Print(string(out))\n}\n\n// SetConfigItem ...\nfunc SetConfigItem(cfg config.Configuration, m map[string]interface{}, configItemPath string, configItemValue string) {\n\tif err := jsonpath.Set(m, configItemPath, configItemValue); err != nil {\n\t\tpanic(errors.Wrap(err, \"\"))\n\t}\n\tif err := cfg.FromMap(m); err != nil {\n\t\tpanic(errors.Wrap(err, \"\"))\n\t}\n}\n\nfunc main() {\n\tconfig.InitDefaultGrokLibraryDir()\n\n\tok, options := OptionsWithCommandLine()\n\tif !ok {\n\t\treturn\n\t}\n\n\tif !options.Debug {\n\t\tdefer func() {\n\t\t\tif p := recover(); p != nil {\n\t\t\t\tcolor.Red.Printf(\"%v\\n\\n\", p)\n\t\t\t\tos.Exit(1)\n\t\t\t\treturn\n\t\t\t}\n\t\t}()\n\t}\n\n\tlogFile := util.InitLogger(config.JogHomeDir(true))\n\tdefer logFile.Close()\n\n\tcfg := ReadConfig(options.ConfigFilePath)\n\n\tif len(options.ConfigItemPath) \u003e 0 {\n\t\tm := cfg.ToMap()\n\t\tif len(options.ConfigItemValue) \u003e 0 {\n\t\t\tSetConfigItem(cfg, m, options.ConfigItemPath, options.ConfigItemValue)\n\t\t} else {\n\t\t\tPrintConfigItem(m, options.ConfigItemPath)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif cfg.LevelField != nil {\n\t\toptions.InitLevelFilters(cfg.LevelField.Enums)\n\t}\n\tif cfg.TimestampField != nil {\n\t\toptions.InitTimestampFilters(cfg.TimestampField)\n\t}\n\n\toptions.InitGroks(cfg)\n\n\tif len(options.LogFilePath) == 0 {\n\t\tlog.Println(\"read JSON log lines from stdin\")\n\t\tProcessReader(cfg, options, os.Stdin, 1)\n\t} else {\n\t\tlog.Printf(\"processing local JSON log file: %s\\n\", options.LogFilePath)\n\t\tProcessLocalFile(cfg, options, options.FollowMode, options.LogFilePath)\n\t}\n\n\tfmt.Println()\n}\n",
    "test_code": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseConfigExpression(t *testing.T) {\n\ttestCases := []struct {\n\t\texpr       string\n\t\texpectedKey  string\n\t\texpectedValue string\n\t\texpectError bool\n\t}{\n\t\t{\"key=value\", \"key\", \"value\", false},\n\t\t{\"invalid_expr\", \"\", \"\", true},\n\t\t{\"another_key=another_value\", \"another_key\", \"another_value\", false},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"expr=%s\", tc.expr), func(t *testing.T) {\n\t\t\tkey, value, err := ParseConfigExpression(tc.expr)\n\t\t\tif tc.expectError {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.Equal(t, tc.expectedKey, key)\n\t\t\t\tassert.Equal(t, tc.expectedValue, value)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReadConfig(t *testing.T) {\n\ttestCases := []struct {\n\t\tconfigFilePath string\n\t\texpected     config.Configuration\n\t}{\n\t\t{\"\", config.WithDefaultYamlFile()},\n\t\t{\"path/to/config.yaml\", config.WithYamlFile(\"path/to/config.yaml\")},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"configFilePath=%s\", tc.configFilePath), func(t *testing.T) {\n\t\t\tresult := ReadConfig(tc.configFilePath)\n\t\t\tassert.Equal(t, tc.expected, result)\n\t\t})\n\t}\n}\n\nfunc TestPrintConfigItem(t *testing.T) {\n\ttestCases := []struct {\n\t\tconfigItemPath string\n\t\texpected       string\n\t}{\n\t\t{\"key\", \"value\"},\n\t\t{\"nonexistent_key\", \"\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"configItemPath=%s\", tc.configItemPath), func(t *testing.T) {\n\t\t\tm := map[string]interface{}{\n\t\t\t\t\"key\": \"value\",\n\t\t\t}\n\t\t\tvar output strings.Builder\n\t\t\toldPrint := fmt.Print\n\t\t\tdefer func() { fmt.Print = oldPrint }()\n\t\t\tfmt.Print = func(s string) {\n\t\t\t\toutput.WriteString(s)\n\t\t\t}\n\n\t\t\tPrintConfigItem(m, tc.configItemPath)\n\n\t\t\tif tc.expected == \"\" {\n\t\t\t\tassert.Empty(t, output.String())\n\t\t\t} else {\n\t\t\t\tassert.Equal(t, tc.expected, output.String())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestSetConfigItem(t *testing.T) {\n\ttestCases := []struct {\n\t\tconfigItemPath string\n\t\tconfigItemValue string\n\t\texpected       map[string]interface{}\n\t}{\n\t\t{\"key\", \"new_value\", map[string]interface{}{\"key\": \"new_value\"}},\n\t\t{\"nonexistent_key\", \"value\", map[string]interface{}{\"nonexistent_key\": \"value\"}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"configItemPath=%s, configItemValue=%s\", tc.configItemPath, tc.configItemValue), func(t *testing.T) {\n\t\t\tcfg := config.Configuration{}\n\t\t\tm := map[string]interface{}{\n\t\t\t\t\"key\": \"value\",\n\t\t\t}\n\n\t\t\tSetConfigItem(cfg, m, tc.configItemPath, tc.configItemValue)\n\n\t\t\tassert.Equal(t, tc.expected, m)\n\t\t})\n\t}\n}\n",
    "amount_of_generated_test_cases": 10,
    "single_test_run_command": "go test -v ./..."
}