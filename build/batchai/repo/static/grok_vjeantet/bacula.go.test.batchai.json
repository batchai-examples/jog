{
    "path": "static/grok_vjeantet/bacula.go",
    "model_usage_metrics": {
        "Duration": 120000066884,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    },
    "test_file_path": "static/grok_vjeantet/bacula_test.go",
    "existing_test_code": "",
    "original_code": "package grok_vjeantet \n\nconst (\n  // Bacula ...\n  Bacula string = `BACULA_TIMESTAMP %{MONTHDAY}-%{MONTH} %{HOUR}:%{MINUTE}\nBACULA_HOST [a-zA-Z0-9-]+\nBACULA_VOLUME %{USER}\nBACULA_DEVICE %{USER}\nBACULA_DEVICEPATH %{UNIXPATH}\nBACULA_CAPACITY %{INT}{1,3}(,%{INT}{3})*\nBACULA_VERSION %{USER}\nBACULA_JOB %{USER}\n\nBACULA_LOG_MAX_CAPACITY User defined maximum volume capacity %{BACULA_CAPACITY} exceeded on device \\\"%{BACULA_DEVICE:device}\\\" \\(%{BACULA_DEVICEPATH}\\)\nBACULA_LOG_END_VOLUME End of medium on Volume \\\"%{BACULA_VOLUME:volume}\\\" Bytes=%{BACULA_CAPACITY} Blocks=%{BACULA_CAPACITY} at %{MONTHDAY}-%{MONTH}-%{YEAR} %{HOUR}:%{MINUTE}.\nBACULA_LOG_NEW_VOLUME Created new Volume \\\"%{BACULA_VOLUME:volume}\\\" in catalog.\nBACULA_LOG_NEW_LABEL Labeled new Volume \\\"%{BACULA_VOLUME:volume}\\\" on device \\\"%{BACULA_DEVICE:device}\\\" \\(%{BACULA_DEVICEPATH}\\).\nBACULA_LOG_WROTE_LABEL Wrote label to prelabeled Volume \\\"%{BACULA_VOLUME:volume}\\\" on device \\\"%{BACULA_DEVICE}\\\" \\(%{BACULA_DEVICEPATH}\\)\nBACULA_LOG_NEW_MOUNT New volume \\\"%{BACULA_VOLUME:volume}\\\" mounted on device \\\"%{BACULA_DEVICE:device}\\\" \\(%{BACULA_DEVICEPATH}\\) at %{MONTHDAY}-%{MONTH}-%{YEAR} %{HOUR}:%{MINUTE}.\nBACULA_LOG_NOOPEN \\s+Cannot open %{DATA}: ERR=%{GREEDYDATA:berror}\nBACULA_LOG_NOOPENDIR \\s+Could not open directory %{DATA}: ERR=%{GREEDYDATA:berror}\nBACULA_LOG_NOSTAT \\s+Could not stat %{DATA}: ERR=%{GREEDYDATA:berror}\nBACULA_LOG_NOJOBS There are no more Jobs associated with Volume \\\"%{BACULA_VOLUME:volume}\\\". Marking it purged.\nBACULA_LOG_ALL_RECORDS_PRUNED All records pruned from Volume \\\"%{BACULA_VOLUME:volume}\\\"; marking it \\\"Purged\\\"\nBACULA_LOG_BEGIN_PRUNE_JOBS Begin pruning Jobs older than %{INT} month %{INT} days .\nBACULA_LOG_BEGIN_PRUNE_FILES Begin pruning Files.\nBACULA_LOG_PRUNED_JOBS Pruned %{INT} Jobs* for client %{BACULA_HOST:client} from catalog.\nBACULA_LOG_PRUNED_FILES Pruned Files from %{INT} Jobs* for client %{BACULA_HOST:client} from catalog.\nBACULA_LOG_ENDPRUNE End auto prune.\nBACULA_LOG_STARTJOB Start Backup JobId %{INT}, Job=%{BACULA_JOB:job}\nBACULA_LOG_STARTRESTORE Start Restore Job %{BACULA_JOB:job}\nBACULA_LOG_USEDEVICE Using Device \\\"%{BACULA_DEVICE:device}\\\"\nBACULA_LOG_DIFF_FS \\s+%{UNIXPATH} is a different filesystem. Will not descend from %{UNIXPATH} into it.\nBACULA_LOG_JOBEND Job write elapsed time = %{DATA:elapsed}, Transfer rate = %{NUMBER} (K|M|G)? Bytes/second\nBACULA_LOG_NOPRUNE_JOBS No Jobs found to prune.\nBACULA_LOG_NOPRUNE_FILES No Files found to prune.\nBACULA_LOG_VOLUME_PREVWRITTEN Volume \\\"%{BACULA_VOLUME:volume}\\\" previously written, moving to end of data.\nBACULA_LOG_READYAPPEND Ready to append to end of Volume \\\"%{BACULA_VOLUME:volume}\\\" size=%{INT}\nBACULA_LOG_CANCELLING Cancelling duplicate JobId=%{INT}.\nBACULA_LOG_MARKCANCEL JobId %{INT}, Job %{BACULA_JOB:job} marked to be canceled.\nBACULA_LOG_CLIENT_RBJ shell command: run ClientRunBeforeJob \\\"%{GREEDYDATA:runjob}\\\"\nBACULA_LOG_VSS (Generate )?VSS (Writer)?\nBACULA_LOG_MAXSTART Fatal error: Job canceled because max start delay time exceeded.\nBACULA_LOG_DUPLICATE Fatal error: JobId %{INT:duplicate} already running. Duplicate job not allowed.\nBACULA_LOG_NOJOBSTAT Fatal error: No Job status returned from FD.\nBACULA_LOG_FATAL_CONN Fatal error: bsock.c:133 Unable to connect to (Client: %{BACULA_HOST:client}|Storage daemon) on %{HOSTNAME}:%{POSINT}. ERR=(?\u003cberror\u003e%{GREEDYDATA})\nBACULA_LOG_NO_CONNECT Warning: bsock.c:127 Could not connect to (Client: %{BACULA_HOST:client}|Storage daemon) on %{HOSTNAME}:%{POSINT}. ERR=(?\u003cberror\u003e%{GREEDYDATA})\nBACULA_LOG_NO_AUTH Fatal error: Unable to authenticate with File daemon at %{HOSTNAME}. Possible causes:\nBACULA_LOG_NOSUIT No prior or suitable Full backup found in catalog. Doing FULL backup.\nBACULA_LOG_NOPRIOR No prior Full backup Job record found.\n\nBACULA_LOG_JOB (Error: )?Bacula %{BACULA_HOST} %{BACULA_VERSION} \\(%{BACULA_VERSION}\\):\n\nBACULA_LOGLINE %{BACULA_TIMESTAMP:bts} %{BACULA_HOST:hostname} JobId %{INT:jobid}: (%{BACULA_LOG_MAX_CAPACITY}|%{BACULA_LOG_END_VOLUME}|%{BACULA_LOG_NEW_VOLUME}|%{BACULA_LOG_NEW_LABEL}|%{BACULA_LOG_WROTE_LABEL}|%{BACULA_LOG_NEW_MOUNT}|%{BACULA_LOG_NOOPEN}|%{BACULA_LOG_NOOPENDIR}|%{BACULA_LOG_NOSTAT}|%{BACULA_LOG_NOJOBS}|%{BACULA_LOG_ALL_RECORDS_PRUNED}|%{BACULA_LOG_BEGIN_PRUNE_JOBS}|%{BACULA_LOG_BEGIN_PRUNE_FILES}|%{BACULA_LOG_PRUNED_JOBS}|%{BACULA_LOG_PRUNED_FILES}|%{BACULA_LOG_ENDPRUNE}|%{BACULA_LOG_STARTJOB}|%{BACULA_LOG_STARTRESTORE}|%{BACULA_LOG_USEDEVICE}|%{BACULA_LOG_DIFF_FS}|%{BACULA_LOG_JOBEND}|%{BACULA_LOG_NOPRUNE_JOBS}|%{BACULA_LOG_NOPRUNE_FILES}|%{BACULA_LOG_VOLUME_PREVWRITTEN}|%{BACULA_LOG_READYAPPEND}|%{BACULA_LOG_CANCELLING}|%{BACULA_LOG_MARKCANCEL}|%{BACULA_LOG_CLIENT_RBJ}|%{BACULA_LOG_VSS}|%{BACULA_LOG_MAXSTART}|%{BACULA_LOG_DUPLICATE}|%{BACULA_LOG_NOJOBSTAT}|%{BACULA_LOG_FATAL_CONN}|%{BACULA_LOG_NO_CONNECT}|%{BACULA_LOG_NO_AUTH}|%{BACULA_LOG_NOSUIT}|%{BACULA_LOG_JOB}|%{BACULA_LOG_NOPRIOR})\n`\n)\n",
    "test_code": "package grok_vjeantet\n\nimport (\n\t\"testing\"\n)\n\nfunc TestBaculaLogMaxCapacity(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MAX_CAPACITY User defined maximum volume capacity 10,20,30 exceeded on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MAX_CAPACITY User defined maximum volume capacity 100,200,300 exceeded on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MAX_CAPACITY User defined maximum volume capacity 1,2,3 exceeded on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MAX_CAPACITY User defined maximum volume capacity 1000,2000,3000 exceeded on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogMaxCapacity(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogMaxCapacity(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogEndVolume(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_END_VOLUME End of volume reached on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_END_VOLUME End of volume reached on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_END_VOLUME End of volume reached on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_END_VOLUME End of volume reached on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogEndVolume(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogEndVolume(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogNewVolume(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NEW_VOLUME New volume created on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NEW_VOLUME New volume created on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NEW_VOLUME New volume created on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NEW_VOLUME New volume created on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogNewVolume(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogNewVolume(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogNewLabel(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NEW_LABEL New label created on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NEW_LABEL New label created on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NEW_LABEL New label created on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NEW_LABEL New label created on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogNewLabel(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogNewLabel(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogWroteLabel(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WROTE_LABEL Label written on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WROTE_LABEL Label written on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WROTE_LABEL Label written on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WROTE_LABEL Label written on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogWroteLabel(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogWroteLabel(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogMounted(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MOUNTED Volume mounted on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MOUNTED Volume mounted on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MOUNTED Volume mounted on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MOUNTED Volume mounted on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogMounted(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogMounted(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogUnmounted(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_UNMOUNTED Volume unmounted on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_UNMOUNTED Volume unmounted on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_UNMOUNTED Volume unmounted on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_UNMOUNTED Volume unmounted on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogUnmounted(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogUnmounted(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogReadError(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_READ_ERROR Read error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_READ_ERROR Read error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_READ_ERROR Read error on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_READ_ERROR Read error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogReadError(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogReadError(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogWriteError(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WRITE_ERROR Write error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WRITE_ERROR Write error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WRITE_ERROR Write error on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WRITE_ERROR Write error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogWriteError(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogWriteError(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogMediaChanged(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MEDIA_CHANGED Media changed on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MEDIA_CHANGED Media changed on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MEDIA_CHANGED Media changed on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_MEDIA_CHANGED Media changed on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogMediaChanged(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogMediaChanged(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogNoMedia(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NO_MEDIA No media on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NO_MEDIA No media on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NO_MEDIA No media on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NO_MEDIA No media on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogNoMedia(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogNoMedia(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogFull(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_FULL Volume full on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_FULL Volume full on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_FULL Volume full on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_FULL Volume full on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogFull(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogFull(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogWarning(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogWarning(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogWarning(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogError(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogError(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogError(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogCritical(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogCritical(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogCritical(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogDebug(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_DEBUG Debug message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_DEBUG Debug message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_DEBUG Debug message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_DEBUG Debug message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogDebug(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogDebug(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogInfo(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_INFO Informational message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_INFO Informational message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_INFO Informational message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_INFO Informational message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogInfo(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogInfo(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogNotice(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NOTICE Notice message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NOTICE Notice message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NOTICE Notice message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_NOTICE Notice message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogNotice(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogNotice(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogEmergency(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_EMERGENCY Emergency message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_EMERGENCY Emergency message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_EMERGENCY Emergency message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_EMERGENCY Emergency message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogEmergency(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogEmergency(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogAlert(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogAlert(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogAlert(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogWarning(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogWarning(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogWarning(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogError(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogError(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogError(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogCritical(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogCritical(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogCritical(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogAlert(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogAlert(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogAlert(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogWarning(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_WARNING Warning message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogWarning(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogWarning(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogError(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ERROR Error message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogError(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogError(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogCritical(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_CRITICAL Critical error on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogCritical(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogCritical(%q) = %v; want %v\", tc.input, result, tc.expected)\n\t\t}\n\t}\n}\n\nfunc TestBaculaLogAlert(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tinput:    `BACULA_LOG_ALERT Alert message on device \"device\" (/path/to/device)`,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tresult := IsBaculaLogAlert(tc.input)\n\t\tif result != tc.expected {\n\t\t\tt.Errorf(\"IsBaculaLogAlert(%q) = %v; want %v\", tc.input, result, tc.expected)\n",
    "amount_of_generated_test_cases": 10,
    "single_test_run_command": "go test static/grok_vjeantet/bacula_test.go"
}